# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-test` gem.
# Please instead update this file by running `bin/tapioca gem rack-test`.

module ActiveSupport::DescendantsTracker
  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#88
  def descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#92
  def direct_descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#82
  def subclasses; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#66
    def clear(classes); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#62
    def descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#11
    def direct_descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#50
    def disable_clear!; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#77
    def native?; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#58
    def subclasses(klass); end
  end
end

# :nocov:
module Rack
  class << self
    # source://rack/2.2.4/lib/rack/version.rb#26
    def release; end

    # source://rack/2.2.4/lib/rack/version.rb#19
    def version; end
  end
end

module Rack::Auth; end

class Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#13
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#11
  def realm; end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#11
  def realm=(_arg0); end

  private

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#29
  def bad_request; end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#20
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#7
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#31
  def params; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#23
  def parts; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#15
  def provided?; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#11
  def request; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#27
  def scheme; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#19
  def valid?; end

  private

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#40
  def authorization_key; end
end

# source://rack/2.2.4/lib/rack/auth/abstract/request.rb#38
Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/basic.rb#18
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/auth/basic.rb#37
  def challenge; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#41
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/basic.rb#46
  def basic?; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#50
  def credentials; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#54
  def username; end
end

module Rack::Auth::Digest; end

class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#26
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#39
  def call(env); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#22
  def opaque; end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#22
  def opaque=(_arg0); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#24
  def passwords_hashed=(_arg0); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#35
  def passwords_hashed?; end

  private

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#114
  def A1(auth, password); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#118
  def A2(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#104
  def H(data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#110
  def KD(secret, data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#79
  def challenge(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#122
  def digest(auth, password); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#104
  def md5(data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#68
  def params(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#83
  def valid?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#99
  def valid_digest?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#95
  def valid_nonce?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#91
  def valid_opaque?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#87
  def valid_qop?(auth); end
end

# source://rack/2.2.4/lib/rack/auth/digest/md5.rb#66
Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

class Rack::Auth::Digest::Nonce
  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#27
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#35
  def digest; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#47
  def fresh?; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#43
  def stale?; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#31
  def to_s; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#39
  def valid?; end

  class << self
    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#23
    def parse(string); end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def private_key; end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def private_key=(_arg0); end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def time_limit; end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def time_limit=(_arg0); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#25
  def initialize; end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#31
  def [](k); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#35
  def []=(k, v); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#47
  def quote(str); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#41
  def to_s; end

  class << self
    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#15
    def dequote(str); end

    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#8
    def parse(str); end

    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#21
    def split_header_value(str); end
  end
end

# source://rack/2.2.4/lib/rack/auth/digest/params.rb#39
Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#19
  def correct_uri?; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#15
  def digest?; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#11
  def method; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#35
  def method_missing(sym, *args); end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#23
  def nonce; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#27
  def params; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#31
  def respond_to?(sym, *_arg1); end
end

class Rack::BodyProxy
  # source://rack/2.2.4/lib/rack/body_proxy.rb#10
  def initialize(body, &block); end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#23
  def close; end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#35
  def closed?; end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#40
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # source://rack/2.2.4/lib/rack/body_proxy.rb#17
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

class Rack::Builder
  # source://rack/2.2.4/lib/rack/builder.rb#123
  def initialize(default_app = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#243
  def call(env); end

  # source://rack/2.2.4/lib/rack/builder.rb#226
  def freeze_app; end

  # source://rack/2.2.4/lib/rack/builder.rb#219
  def map(path, &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#176
  def run(app); end

  # source://rack/2.2.4/lib/rack/builder.rb#231
  def to_app; end

  # source://rack/2.2.4/lib/rack/builder.rb#153
  def use(middleware, *args, **_arg2, &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#190
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # source://rack/2.2.4/lib/rack/builder.rb#251
  def generate_map(default_app, mapping); end

  class << self
    # source://rack/2.2.4/lib/rack/builder.rb#130
    def app(default_app = T.unsafe(nil), &block); end

    # source://rack/2.2.4/lib/rack/builder.rb#93
    def load_file(path, opts = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/builder.rb#112
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/builder.rb#64
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/builder.rb#36
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#29
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#31
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#32
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

class Rack::Cascade
  # source://rack/2.2.4/lib/rack/cascade.rb#22
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/cascade.rb#57
  def <<(app); end

  # source://rack/2.2.4/lib/rack/cascade.rb#57
  def add(app); end

  # source://rack/2.2.4/lib/rack/cascade.rb#14
  def apps; end

  # source://rack/2.2.4/lib/rack/cascade.rb#33
  def call(env); end

  # source://rack/2.2.4/lib/rack/cascade.rb#62
  def include?(app); end
end

# source://rack/2.2.4/lib/rack/cascade.rb#11
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

class Rack::Chunked
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/chunked.rb#78
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/chunked.rb#97
  def call(env); end

  # source://rack/2.2.4/lib/rack/chunked.rb#83
  def chunkable_version?(ver); end
end

class Rack::Chunked::Body
  # source://rack/2.2.4/lib/rack/chunked.rb#30
  def initialize(body); end

  # source://rack/2.2.4/lib/rack/chunked.rb#50
  def close; end

  # source://rack/2.2.4/lib/rack/chunked.rb#36
  def each(&block); end

  private

  # source://rack/2.2.4/lib/rack/chunked.rb#57
  def yield_trailers; end
end

# source://rack/2.2.4/lib/rack/chunked.rb#27
Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/chunked.rb#26
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # source://rack/2.2.4/lib/rack/chunked.rb#71
  def yield_trailers; end
end

class Rack::CommonLogger
  # source://rack/2.2.4/lib/rack/common_logger.rb#24
  def initialize(app, logger = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/common_logger.rb#36
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/common_logger.rb#78
  def extract_content_length(headers); end

  # source://rack/2.2.4/lib/rack/common_logger.rb#47
  def log(env, status, header, began_at); end
end

# source://rack/2.2.4/lib/rack/common_logger.rb#18
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

class Rack::ConditionalGet
  # source://rack/2.2.4/lib/rack/conditional_get.rb#18
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#24
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/conditional_get.rb#59
  def etag_matches?(none_match, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#48
  def fresh?(env, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#65
  def modified_since?(modified_since, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#72
  def to_rfc2822(since); end
end

class Rack::Config
  # source://rack/2.2.4/lib/rack/config.rb#12
  def initialize(app, &block); end

  # source://rack/2.2.4/lib/rack/config.rb#17
  def call(env); end
end

class Rack::ContentLength
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/content_length.rb#12
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/content_length.rb#16
  def call(env); end
end

class Rack::ContentType
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/content_type.rb#15
  def initialize(app, content_type = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/content_type.rb#19
  def call(env); end
end

# source://rack/2.2.4/lib/rack.rb#43
Rack::DELETE = T.let(T.unsafe(nil), String)

class Rack::Deflater
  # source://rack/2.2.4/lib/rack/deflater.rb#36
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/deflater.rb#43
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/deflater.rb#122
  def should_deflate?(env, status, headers, body); end
end

class Rack::Deflater::GzipStream
  # source://rack/2.2.4/lib/rack/deflater.rb#85
  def initialize(body, mtime, sync); end

  # source://rack/2.2.4/lib/rack/deflater.rb#114
  def close; end

  # source://rack/2.2.4/lib/rack/deflater.rb#92
  def each(&block); end

  # source://rack/2.2.4/lib/rack/deflater.rb#109
  def write(data); end
end

class Rack::Directory
  # source://rack/2.2.4/lib/rack/directory.rb#77
  def initialize(root, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/directory.rb#83
  def call(env); end

  # source://rack/2.2.4/lib/rack/directory.rb#103
  def check_bad_request(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#113
  def check_forbidden(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#175
  def entity_not_found(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#191
  def filesize_format(int); end

  # source://rack/2.2.4/lib/rack/directory.rb#90
  def get(env); end

  # source://rack/2.2.4/lib/rack/directory.rb#124
  def list_directory(path_info, path, script_name); end

  # source://rack/2.2.4/lib/rack/directory.rb#165
  def list_path(env, path, path_info, script_name); end

  # source://rack/2.2.4/lib/rack/directory.rb#74
  def root; end

  # source://rack/2.2.4/lib/rack/directory.rb#157
  def stat(path); end
end

# source://rack/2.2.4/lib/rack/directory.rb#14
Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/directory.rb#37
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/directory.rb#15
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

class Rack::Directory::DirectoryBody < ::Struct
  # source://rack/2.2.4/lib/rack/directory.rb#47
  def each; end

  private

  # source://rack/2.2.4/lib/rack/directory.rb#67
  def DIR_FILE_escape(htmls); end
end

# source://rack/2.2.4/lib/rack/directory.rb#183
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack.rb#36
Rack::ETAG = T.let(T.unsafe(nil), String)

class Rack::ETag
  # source://rack/2.2.4/lib/rack/etag.rb#20
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/etag.rb#26
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/etag.rb#65
  def digest_body(body); end

  # source://rack/2.2.4/lib/rack/etag.rb#57
  def etag_body?(body); end

  # source://rack/2.2.4/lib/rack/etag.rb#53
  def etag_status?(status); end

  # source://rack/2.2.4/lib/rack/etag.rb#61
  def skip_caching?(headers); end
end

# source://rack/2.2.4/lib/rack/etag.rb#18
Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/etag.rb#17
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#30
Rack::EXPIRES = T.let(T.unsafe(nil), String)

class Rack::Events
  # source://rack/2.2.4/lib/rack/events.rb#102
  def initialize(app, handlers); end

  # source://rack/2.2.4/lib/rack/events.rb#107
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/events.rb#145
  def make_request(env); end

  # source://rack/2.2.4/lib/rack/events.rb#149
  def make_response(status, headers, body); end

  # source://rack/2.2.4/lib/rack/events.rb#133
  def on_commit(request, response); end

  # source://rack/2.2.4/lib/rack/events.rb#129
  def on_error(request, response, e); end

  # source://rack/2.2.4/lib/rack/events.rb#141
  def on_finish(request, response); end

  # source://rack/2.2.4/lib/rack/events.rb#137
  def on_start(request, response); end
end

module Rack::Events::Abstract
  # source://rack/2.2.4/lib/rack/events.rb#62
  def on_commit(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#71
  def on_error(req, res, e); end

  # source://rack/2.2.4/lib/rack/events.rb#68
  def on_finish(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#65
  def on_send(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#59
  def on_start(req, res); end
end

class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # source://rack/2.2.4/lib/rack/events.rb#94
  def initialize(status, headers, body); end

  # source://rack/2.2.4/lib/rack/events.rb#92
  def body; end

  # source://rack/2.2.4/lib/rack/events.rb#99
  def to_a; end
end

class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # source://rack/2.2.4/lib/rack/events.rb#78
  def initialize(body, request, response, handlers, &block); end

  # source://rack/2.2.4/lib/rack/events.rb#85
  def each; end

  # source://rack/2.2.4/lib/rack/events.rb#76
  def request; end

  # source://rack/2.2.4/lib/rack/events.rb#76
  def response; end
end

# source://rack/2.2.4/lib/rack/file.rb#6
Rack::File = Rack::Files

class Rack::Files
  # source://rack/2.2.4/lib/rack/files.rb#29
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/files.rb#36
  def call(env); end

  # source://rack/2.2.4/lib/rack/files.rb#41
  def get(env); end

  # source://rack/2.2.4/lib/rack/files.rb#27
  def root; end

  # source://rack/2.2.4/lib/rack/files.rb#70
  def serving(request, path); end

  private

  # source://rack/2.2.4/lib/rack/files.rb#192
  def fail(status, body, headers = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/files.rb#211
  def filesize(path); end

  # source://rack/2.2.4/lib/rack/files.rb#207
  def mime_type(path, default_mime); end

  class << self
    # source://rack/2.2.4/lib/rack/files.rb#20
    def method_added(name); end
  end
end

# source://rack/2.2.4/lib/rack/files.rb#15
Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/files.rb#16
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

class Rack::Files::BaseIterator
  # source://rack/2.2.4/lib/rack/files.rb#126
  def initialize(path, ranges, options); end

  # source://rack/2.2.4/lib/rack/files.rb#146
  def bytesize; end

  # source://rack/2.2.4/lib/rack/files.rb#155
  def close; end

  # source://rack/2.2.4/lib/rack/files.rb#132
  def each; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def options; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def path; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def ranges; end

  private

  # source://rack/2.2.4/lib/rack/files.rb#173
  def each_range_part(file, range); end

  # source://rack/2.2.4/lib/rack/files.rb#159
  def multipart?; end

  # source://rack/2.2.4/lib/rack/files.rb#163
  def multipart_heading(range); end
end

class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  # source://rack/2.2.4/lib/rack/files.rb#124
  def to_path; end
end

# source://rack/2.2.4/lib/rack/files.rb#17
Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

class Rack::ForwardRequest < ::Exception
  # source://rack/2.2.4/lib/rack/recursive.rb#15
  def initialize(url, env = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/recursive.rb#13
  def env; end

  # source://rack/2.2.4/lib/rack/recursive.rb#13
  def url; end
end

# source://rack/2.2.4/lib/rack.rb#39
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#44
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#20
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#35
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#17
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#18
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#19
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

module Rack::Handler
  class << self
    # source://rack/2.2.4/lib/rack/handler.rb#51
    def default; end

    # source://rack/2.2.4/lib/rack/handler.rb#13
    def get(server); end

    # source://rack/2.2.4/lib/rack/handler.rb#36
    def pick(server_names); end

    # source://rack/2.2.4/lib/rack/handler.rb#85
    def register(server, klass); end

    # source://rack/2.2.4/lib/rack/handler.rb#75
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::CGI
  class << self
    # source://rack/2.2.4/lib/rack/handler/cgi.rb#6
    def run(app, **options); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#51
    def send_body(body); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#40
    def send_headers(status, headers); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#11
    def serve(app); end
  end
end

class Rack::Handler::WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  # source://rack/2.2.4/lib/rack/handler/webrick.rb#61
  def initialize(server, app); end

  # source://rack/2.2.4/lib/rack/handler/webrick.rb#66
  def service(req, res); end

  class << self
    # source://rack/2.2.4/lib/rack/handler/webrick.rb#26
    def run(app, **options); end

    # source://rack/2.2.4/lib/rack/handler/webrick.rb#54
    def shutdown; end

    # source://rack/2.2.4/lib/rack/handler/webrick.rb#44
    def valid_options; end
  end
end

class Rack::Head
  # source://rack/2.2.4/lib/rack/head.rb#7
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/head.rb#11
  def call(env); end
end

# source://rack/2.2.4/lib/rack.rb#46
Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::Lint
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#10
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/lint.rb#41
  def _call(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#37
  def call(env = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/lint.rb#719
  def check_content_length(status, headers); end

  # source://rack/2.2.4/lib/rack/lint.rb#705
  def check_content_type(status, headers); end

  # source://rack/2.2.4/lib/rack/lint.rb#77
  def check_env(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#497
  def check_error(error); end

  # source://rack/2.2.4/lib/rack/lint.rb#668
  def check_headers(header); end

  # source://rack/2.2.4/lib/rack/lint.rb#562
  def check_hijack(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#609
  def check_hijack_response(headers, env); end

  # source://rack/2.2.4/lib/rack/lint.rb#377
  def check_input(input); end

  # source://rack/2.2.4/lib/rack/lint.rb#661
  def check_status(status); end

  # source://rack/2.2.4/lib/rack/lint.rb#792
  def close; end

  # source://rack/2.2.4/lib/rack/lint.rb#745
  def each; end

  # source://rack/2.2.4/lib/rack/lint.rb#732
  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  # source://rack/2.2.4/lib/rack/lint.rb#19
  def assert(message); end
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#509
  def initialize(error); end

  # source://rack/2.2.4/lib/rack/lint.rb#531
  def close(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#526
  def flush; end

  # source://rack/2.2.4/lib/rack/lint.rb#514
  def puts(str); end

  # source://rack/2.2.4/lib/rack/lint.rb#519
  def write(str); end
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  extend ::Forwardable

  # source://rack/2.2.4/lib/rack/lint.rb#547
  def initialize(io); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def closed?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flush(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read_nonblock(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write_nonblock(*args, **_arg1, &block); end
end

# source://rack/2.2.4/lib/rack/lint.rb#540
Rack::Lint::HijackWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#398
  def initialize(input); end

  # source://rack/2.2.4/lib/rack/lint.rb#491
  def close(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#463
  def each(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#404
  def gets(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#430
  def read(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#478
  def rewind(*args); end
end

class Rack::Lint::LintError < ::RuntimeError; end

class Rack::Lock
  # source://rack/2.2.4/lib/rack/lock.rb#9
  def initialize(app, mutex = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/lock.rb#13
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/lock.rb#27
  def unlock; end
end

class Rack::Logger
  # source://rack/2.2.4/lib/rack/logger.rb#8
  def initialize(app, level = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/logger.rb#12
  def call(env); end
end

class Rack::MediaType
  class << self
    # source://rack/2.2.4/lib/rack/media_type.rb#26
    def params(content_type); end

    # source://rack/2.2.4/lib/rack/media_type.rb#16
    def type(content_type); end

    private

    # source://rack/2.2.4/lib/rack/media_type.rb#38
    def strip_doublequotes(str); end
  end
end

# source://rack/2.2.4/lib/rack/media_type.rb#7
Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rack::MethodOverride
  # source://rack/2.2.4/lib/rack/method_override.rb#11
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/method_override.rb#15
  def call(env); end

  # source://rack/2.2.4/lib/rack/method_override.rb#27
  def method_override(env); end

  private

  # source://rack/2.2.4/lib/rack/method_override.rb#40
  def allowed_methods; end

  # source://rack/2.2.4/lib/rack/method_override.rb#44
  def method_override_param(req); end
end

# source://rack/2.2.4/lib/rack/method_override.rb#9
Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/method_override.rb#5
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/method_override.rb#8
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/method_override.rb#7
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime
  private

  # source://rack/2.2.4/lib/rack/mime.rb#30
  def match?(value, matcher); end

  # source://rack/2.2.4/lib/rack/mime.rb#18
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.4/lib/rack/mime.rb#30
    def match?(value, matcher); end

    # source://rack/2.2.4/lib/rack/mime.rb#18
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/mime.rb#51
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

class Rack::MiniProfiler
  extend ::Rack::MiniProfiler::ProfilingMethods

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#115
  def initialize(app, config = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#206
  def advanced_debugging_enabled?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#575
  def analyze_memory; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#792
  def cache_control_value; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#214
  def call(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#788
  def cancel_auto_inject(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#202
  def config; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#194
  def current; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#198
  def current=(c); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#547
  def dump_env(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#529
  def dump_exceptions(exceptions); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#682
  def flamegraph(graph, path); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#167
  def generate_html(page_struct, env, result_json = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#730
  def get_profile_script(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#651
  def help(client_settings, env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#711
  def ids(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#720
  def ids_comma_separated(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#508
  def inject(fragment, script); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#474
  def inject_profiler(env, status, headers, body); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#646
  def make_link(postfix, env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#179
  def serve_html(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#130
  def serve_results(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#641
  def text_result(body); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#210
  def tool_disabled_message(client_settings); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#569
  def trim_strings(strings, max_size); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#126
  def user(env); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#798
  def handle_snapshots_request(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#863
  def rails_route_from_path(path, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#845
  def serve_flamegraph(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#890
  def take_snapshot(env, start); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#884
  def take_snapshot?(path); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#879
  def url_for_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#874
  def url_for_snapshots_group(group_name); end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#48
    def add_snapshot_custom_field(key, value); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#84
    def advanced_tools_message; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#72
    def authorize_request; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#90
    def binds_to_params(binds); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#25
    def config; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#63
    def create_current(env = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#37
    def current; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#41
    def current=(c); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#76
    def deauthorize_request; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#59
    def discard_results; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#16
    def generate_id; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#54
    def get_snapshot_custom_fields; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#12
    def patch_rails?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#106
    def redact_sql_queries?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#80
    def request_authorized?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#20
    def reset_config; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#29
    def resources_root; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#33
    def share_template; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#101
    def snapshots_transporter?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#10
    def subscribe_sql_active_record; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#10
    def subscribe_sql_active_record=(_arg0); end
  end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/asset_version.rb#4
Rack::MiniProfiler::ASSET_VERSION = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#40
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#34
  def diagnostics(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#63
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#57
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#30
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#14
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#67
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#48
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#10
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#26
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#18
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#22
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#44
  def should_take_snapshot?(period); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#79
  def snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#71
  def snapshots_overview; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#8
Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::ClientSettings
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#16
  def initialize(env, store, start); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#118
  def backtrace_default?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#114
  def backtrace_full?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#14
  def backtrace_level; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#14
  def backtrace_level=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#122
  def backtrace_none?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#13
  def disable_profiling; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#13
  def disable_profiling=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#110
  def disable_profiling?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#84
  def discard_cookie!(headers); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#42
  def handle_cookie(result); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#90
  def has_valid_cookie?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#58
  def write!(headers); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#9
Rack::MiniProfiler::ClientSettings::BACKTRACE_DEFAULT = T.let(T.unsafe(nil), T.untyped)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#10
Rack::MiniProfiler::ClientSettings::BACKTRACE_FULL = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#11
Rack::MiniProfiler::ClientSettings::BACKTRACE_NONE = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#7
Rack::MiniProfiler::ClientSettings::COOKIE_NAME = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::Config
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#93
  def assets_url; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#111
  def assets_url=(lmbda); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def authorization_mode; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#97
  def authorization_mode=(mode); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def auto_inject; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def auto_inject=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_ignores; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_ignores=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_includes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_includes=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_remove; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_remove=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_threshold_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_threshold_ms=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def base_url_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def base_url_path=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def collapse_results; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def collapse_results=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def content_security_policy_nonce; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def content_security_policy_nonce=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def cookie_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def cookie_path=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def disable_caching; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def disable_caching=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_advanced_debugging_tools; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_advanced_debugging_tools=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_hotwire_turbo_drive_support; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_hotwire_turbo_drive_support=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enabled; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enabled=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_mode; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_mode=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_sample_rate; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_sample_rate=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#122
  def horizontal_position; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def html_container; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def html_container=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def logger; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def logger=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshot_groups; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshot_groups=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshots_per_group; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshots_per_group=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_sql_param_length; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_sql_param_length=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_traces_to_show; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_traces_to_show=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#126
  def merge!(config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def position; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def position=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def pre_authorize_cb; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def pre_authorize_cb=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_children; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_children=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_controls; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_controls=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_total_sql_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_total_sql_count=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_trivial; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_trivial=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_paths; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_paths=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_schema_queries; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_schema_queries=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_sql_param_names; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_sql_param_names=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_every_n_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_every_n_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_hidden_custom_fields; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_hidden_custom_fields=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_redact_sql_queries; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_redact_sql_queries=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_auth_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_auth_key=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_destination_url; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_destination_url=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_gzip_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_gzip_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def start_hidden; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def start_hidden=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_failure; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_failure=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_instance; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_instance=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_options; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_options=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def suppress_encoding; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def suppress_encoding=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def toggle_shortcut; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def toggle_shortcut=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def use_existing_jquery; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def use_existing_jquery=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def user_provider; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def user_provider=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#118
  def vertical_position; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#6
    def attr_accessor(*vars); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#12
    def attributes; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#16
    def default; end
  end
end

class Rack::MiniProfiler::Context
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def current_timer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def current_timer=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def discard; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def discard=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def full_backtrace; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def full_backtrace=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def inject_js; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def inject_js=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def measure; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def measure=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def mpt_init; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def mpt_init=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def page_struct; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def page_struct=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def skip_backtrace; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def skip_backtrace=(_arg0); end
end

class Rack::MiniProfiler::FileStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#49
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#145
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#161
  def cleanup_cache; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#139
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#133
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#102
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#96
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#127
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#108
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#117
  def set_viewed(user, id); end
end

class Rack::MiniProfiler::FileStore::CacheCleanupThread < ::Thread; end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#47
Rack::MiniProfiler::FileStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::FileStore::FileCache
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#12
  def initialize(path, prefix); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#17
  def [](key); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#28
  def []=(key, val); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#41
  def path(key); end
end

class Rack::MiniProfiler::GCProfiler
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#5
  def initialize; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#63
  def analyze_growth(ids_before, ids_after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#79
  def analyze_initial_state(ids_before); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#51
  def analyze_strings(ids_before, ids_after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#39
  def diff_object_stats(before, after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#10
  def object_space_stats; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#94
  def profile_gc(app, env); end
end

class Rack::MiniProfiler::MemcacheStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#10
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#64
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#60
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#56
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#25
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#21
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#52
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#32
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#42
  def set_viewed(user, id); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#7
Rack::MiniProfiler::MemcacheStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#8
Rack::MiniProfiler::MemcacheStore::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#50
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#130
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#123
  def cleanup_cache; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#202
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#188
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#117
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#74
  def initialize_cleanup_thread(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#63
  def initialize_locks; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#91
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#213
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#156
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#85
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#111
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#97
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#104
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#144
  def should_take_snapshot?(period); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#225
  def wipe_snapshots_data; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#48
Rack::MiniProfiler::MemoryStore::CLEANUP_CYCLE = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#47
Rack::MiniProfiler::MemoryStore::CLEANUP_INTERVAL = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore::CacheCleanupThread < ::Thread
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#10
  def initialize(interval, cycle, store); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#32
  def cleanup; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#37
  def cycle_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#41
  def increment_cycle; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#18
  def should_cleanup?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#26
  def sleepy_run; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#46
Rack::MiniProfiler::MemoryStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

module Rack::MiniProfiler::ProfilingMethods
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#143
  def counter(type, duration_ms = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#64
  def counter_method(klass, method, &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#27
  def finish_step(obj); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#72
  def profile_method(klass, method, type = T.unsafe(nil), &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#124
  def profile_singleton_method(klass, method, type = T.unsafe(nil), &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#7
  def record_sql(query, elapsed_ms, params = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#20
  def start_step(name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#35
  def step(name, opts = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#68
  def uncounter_method(klass, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#50
  def unprofile_method(klass, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#128
  def unprofile_singleton_method(klass, method); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#157
  def clean_method_name(method); end
end

class Rack::MiniProfiler::RedisStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#13
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#87
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#70
  def diagnostics(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#230
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#206
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#78
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#64
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#24
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#247
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#9
  def prefix; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#136
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#20
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#47
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#38
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#59
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#126
  def should_take_snapshot?(period); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#83
  def simulate_expire; end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#298
  def cached_redis_eval(script, script_sha, reraise: T.unsafe(nil), argv: T.unsafe(nil), keys: T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#310
  def cleanup_corrupt_snapshots(corrupt_snapshots_ids, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#288
  def group_snapshot_hash_key(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#282
  def group_snapshot_zset_key(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#267
  def prefixed_id(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#271
  def redis; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#278
  def snapshot_counter_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#294
  def snapshot_overview_zset_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#263
  def user_key(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#341
  def wipe_snapshots_data; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#115
Rack::MiniProfiler::RedisStore::COUNTER_LUA = T.let(T.unsafe(nil), String)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#124
Rack::MiniProfiler::RedisStore::COUNTER_LUA_SHA = T.let(T.unsafe(nil), String)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#11
Rack::MiniProfiler::RedisStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/version.rb#6
Rack::MiniProfiler::SOURCE_CODE_URI = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::SnapshotsTransporter
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#28
  def initialize(config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#25
  def buffer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#49
  def flush_buffer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def gzip_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def gzip_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def max_buffer_size; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def max_buffer_size=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#89
  def requests_interval; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#41
  def ship(snapshot); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#95
  def backoff_delay; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#100
  def start_thread; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#15
    def failed_http_requests_count; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#12
    def successful_http_requests_count; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#19
    def transport(snapshot); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#9
    def transported_snapshots_count; end
  end
end

module Rack::MiniProfiler::TimerStruct; end

class Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#9
  def initialize(attrs = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#17
  def [](name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#21
  def []=(name, val); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#32
  def as_json(options = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#13
  def attributes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#26
  def to_json(*a); end
end

class Rack::MiniProfiler::TimerStruct::Client < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#27
  def initialize(env = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#31
  def redirect_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#35
  def timings; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#39
    def init_from_form_data(env, page_struct); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#10
    def init_instrumentation; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#19
    def instrument(name, orig); end
  end
end

class Rack::MiniProfiler::TimerStruct::Custom < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#10
  def initialize(type, duration_ms, page, parent); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#9
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#9
  def parent=(_arg0); end
end

class Rack::MiniProfiler::TimerStruct::Page < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#60
  def initialize(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#124
  def as_json(options = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#58
  def attributes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#116
  def attributes_to_serialize; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#104
  def duration_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#108
  def duration_ms_in_sql; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#128
  def extra_json; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#100
  def name; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#112
  def root; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#120
  def to_json(*a); end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#14
    def from_hash(hash); end

    private

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#45
    def symbolize_array(array); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#30
    def symbolize_hash(hash); end
  end
end

class Rack::MiniProfiler::TimerStruct::Request < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#16
  def initialize(name, page, parent); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#81
  def add_child(name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#128
  def add_custom(type, elapsed_ms, page); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#104
  def add_sql(query, elapsed_ms, page, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#172
  def adjust_depth; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#69
  def children; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def children_duration; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def children_duration=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#73
  def custom_timings; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#65
  def depth; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#53
  def duration_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#57
  def duration_ms_in_sql; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#90
  def move_child(child, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#145
  def move_custom(type, custom, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#115
  def move_sql(sql, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#49
  def name; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def parent=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#165
  def record_time(milliseconds = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#77
  def sql_timings; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def start; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def start=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#61
  def start_ms; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#8
    def createRoot(name, page); end
  end
end

class Rack::MiniProfiler::TimerStruct::Sql < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#11
  def initialize(query, duration_ms, page, parent, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#9
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#9
  def parent=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#52
  def report_reader_duration(elapsed_ms); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#60
  def trim_binds(binds); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/version.rb#5
Rack::MiniProfiler::VERSION = T.let(T.unsafe(nil), String)

module Rack::MiniProfilerRails
  extend ::Rack::MiniProfilerRailsMethods

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#121
    def create_engine; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#142
    def get_key(payload); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#10
    def initialize!(app); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#150
    def serves_static_assets?(app); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#146
    def shorten_identifier(identifier); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#132
    def subscribe(event, &blk); end
  end
end

class Rack::MiniProfilerRails::Railtie < ::Rails::Railtie; end

module Rack::MiniProfilerRailsMethods
  extend ::Rack::MiniProfilerRailsMethods

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#54
  def get_webpacker_assets_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#4
  def render_notification_handler(name, finish, start, name_as_description: T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#42
  def should_measure?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#47
  def should_move?(child, node); end
end

class Rack::MockRequest
  # source://rack/2.2.4/lib/rack/mock.rb#52
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/mock.rb#65
  def delete(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#57
  def get(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#67
  def head(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#69
  def options(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#63
  def patch(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#59
  def post(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#61
  def put(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#74
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.4/lib/rack/mock.rb#105
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/mock.rb#92
    def parse_uri_rfc2396(uri); end
  end
end

# source://rack/2.2.4/lib/rack/mock.rb#43
Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  # source://rack/2.2.4/lib/rack/mock.rb#35
  def flush; end

  # source://rack/2.2.4/lib/rack/mock.rb#27
  def puts(warning); end

  # source://rack/2.2.4/lib/rack/mock.rb#38
  def string; end

  # source://rack/2.2.4/lib/rack/mock.rb#31
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError; end

class Rack::MockResponse < ::Rack::Response
  # source://rack/2.2.4/lib/rack/mock.rb#184
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#194
  def =~(other); end

  # source://rack/2.2.4/lib/rack/mock.rb#202
  def body; end

  # source://rack/2.2.4/lib/rack/mock.rb#226
  def cookie(name); end

  # source://rack/2.2.4/lib/rack/mock.rb#179
  def cookies; end

  # source://rack/2.2.4/lib/rack/mock.rb#222
  def empty?; end

  # source://rack/2.2.4/lib/rack/mock.rb#182
  def errors; end

  # source://rack/2.2.4/lib/rack/mock.rb#182
  def errors=(_arg0); end

  # source://rack/2.2.4/lib/rack/mock.rb#198
  def match(other); end

  # source://rack/2.2.4/lib/rack/mock.rb#179
  def original_headers; end

  private

  # source://rack/2.2.4/lib/rack/mock.rb#253
  def identify_cookie_attributes(cookie_filling); end

  # source://rack/2.2.4/lib/rack/mock.rb#232
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

# For backwards compatibility with 1.1.0 and below
#
# source://rack-test//lib/rack/test.rb#413
Rack::MockSession = Rack::Test::Session

module Rack::Multipart
  class << self
    # source://rack/2.2.4/lib/rack/multipart.rb#58
    def build_multipart(params, first = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/multipart.rb#44
    def extract_multipart(req, params = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/multipart.rb#40
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/multipart.rb#25
Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#24
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#19
Rack::Multipart::BROKEN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#17
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#36
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#13
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#32
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#34
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#33
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#29
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#31
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#30
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#35
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::Generator
  # source://rack/2.2.4/lib/rack/multipart/generator.rb#6
  def initialize(params, first = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#14
  def dump; end

  private

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#87
  def content_for_other(file, name); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#75
  def content_for_tempfile(io, file, name); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#50
  def flattened_params; end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#35
  def multipart?; end
end

# source://rack/2.2.4/lib/rack/multipart.rb#15
Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#14
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#21
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#22
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#20
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end

class Rack::Multipart::Parser
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#167
  def initialize(boundary, tempfile, bufsize, query_parser); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#185
  def on_read(content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#191
  def result; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#165
  def state; end

  private

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#283
  def consume_boundary; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#281
  def full_boundary; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#293
  def get_filename(head); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#229
  def handle_consume_token; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#358
  def handle_empty_content!(content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#220
  def handle_fast_forward; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#262
  def handle_mime_body; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#239
  def handle_mime_head; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#203
  def run_parser; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#330
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    # source://rack/2.2.4/lib/rack/multipart/parser.rb#63
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end

    # source://rack/2.2.4/lib/rack/multipart/parser.rb#56
    def parse_boundary(content_type); end
  end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#18
Rack::Multipart::Parser::BOUNDARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart/parser.rb#12
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Rack::Multipart::Parser::BoundedIO
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#21
  def initialize(io, content_length); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#27
  def read(size, outbuf = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#48
  def rewind; end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#328
Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#120
  def initialize(tempfile); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#126
  def each; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#146
  def on_mime_body(mime_index, content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#150
  def on_mime_finish(mime_index); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#130
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#155
  def check_open_files; end
end

class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#110
  def close; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#109
  def file?; end
end

class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#86
  def get_data; end
end

class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#115
  def close; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#114
  def file?; end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#54
Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

class Rack::Multipart::Parser::MultipartInfo < ::Struct
  def params; end
  def params=(_); end
  def tmp_files; end
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#14
Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)

# source://rack/2.2.4/lib/rack/multipart/parser.rb#13
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#28
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#27
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#37
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#26
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#16
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#12
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#10
  def content_type; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#10
  def content_type=(_arg0); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#27
  def local_path; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#36
  def method_missing(method_name, *args, &block); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#7
  def original_filename; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#27
  def path; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#32
  def respond_to?(*args); end
end

# source://rack/2.2.4/lib/rack/multipart.rb#18
Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

class Rack::NullLogger
  # source://rack/2.2.4/lib/rack/null_logger.rb#5
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#37
  def <<(msg); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#36
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#9
  def call(env); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#35
  def close; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#27
  def datetime_format; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#32
  def datetime_format=(datetime_format); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#15
  def debug(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#21
  def debug?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#17
  def error(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#23
  def error?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#18
  def fatal(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#24
  def fatal?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#28
  def formatter; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#33
  def formatter=(formatter); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#14
  def info(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#20
  def info?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#25
  def level; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#30
  def level=(level); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#26
  def progname; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#31
  def progname=(progname); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#29
  def sev_threshold; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#34
  def sev_threshold=(sev_threshold); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#19
  def unknown(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#16
  def warn(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#22
  def warn?; end
end

# source://rack/2.2.4/lib/rack.rb#45
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#42
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#21
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#40
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#41
Rack::PUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#25
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

class Rack::QueryParser
  # source://rack/2.2.4/lib/rack/query_parser.rb#29
  def initialize(params_class, key_space_limit, param_depth_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#27
  def key_space_limit; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#128
  def make_params; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#136
  def new_depth_limit(param_depth_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#132
  def new_space_limit(key_space_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#87
  def normalize_params(params, name, v, depth); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#27
  def param_depth_limit; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#68
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#40
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  private

  # source://rack/2.2.4/lib/rack/query_parser.rb#146
  def params_hash_has_key?(hash, key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#142
  def params_hash_type?(obj); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#158
  def unescape(s); end

  class << self
    # source://rack/2.2.4/lib/rack/query_parser.rb#23
    def make_default(key_space_limit, param_depth_limit); end
  end
end

# source://rack/2.2.4/lib/rack/query_parser.rb#8
Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/query_parser.rb#7
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

class Rack::QueryParser::Params
  # source://rack/2.2.4/lib/rack/query_parser.rb#163
  def initialize(limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#169
  def [](key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#173
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#179
  def key?(key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#201
  def to_h; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#201
  def to_params_hash; end
end

class Rack::QueryParser::ParamsTooDeepError < ::RangeError; end

# source://rack/2.2.4/lib/rack.rb#53
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#63
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#65
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#55
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#64
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#54
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#76
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#67
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#68
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#60
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#59
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#66
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#72
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#73
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#70
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#69
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#71
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#74
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#75
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#61
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#56
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#57
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#77
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#58
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#52
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#62
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#51
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/version.rb#23
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#22
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#23
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

class Rack::Recursive
  # source://rack/2.2.4/lib/rack/recursive.rb#35
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/recursive.rb#43
  def _call(env); end

  # source://rack/2.2.4/lib/rack/recursive.rb#39
  def call(env); end

  # source://rack/2.2.4/lib/rack/recursive.rb#50
  def include(env, path); end
end

class Rack::Reloader
  # source://rack/2.2.4/lib/rack/reloader.rb#27
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/reloader.rb#38
  def call(env); end

  # source://rack/2.2.4/lib/rack/reloader.rb#52
  def reload!(stderr = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/reloader.rb#60
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  # source://rack/2.2.4/lib/rack/reloader.rb#90
  def figure_path(file, paths); end

  # source://rack/2.2.4/lib/rack/reloader.rb#71
  def rotation; end

  # source://rack/2.2.4/lib/rack/reloader.rb#105
  def safe_stat(file); end
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # source://rack/2.2.4/lib/rack/request.rb#26
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/request.rb#40
  def delete_param(k); end

  # source://rack/2.2.4/lib/rack/request.rb#31
  def params; end

  # source://rack/2.2.4/lib/rack/request.rb#31
  def query; end

  # source://rack/2.2.4/lib/rack/request.rb#35
  def update_param(k, v); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied; end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied=(_arg0); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#88
  def xhr?; end

  class << self
    # source://rack/2.2.4/lib/rack/request.rb#16
    def ip_filter; end

    # source://rack/2.2.4/lib/rack/request.rb#16
    def ip_filter=(_arg0); end
  end
end

# source://rack/2.2.4/lib/rack/request.rb#20
Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

module Rack::Request::Env
  # source://rack/2.2.4/lib/rack/request.rb#50
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/request.rb#91
  def add_header(key, v); end

  # source://rack/2.2.4/lib/rack/request.rb#102
  def delete_header(name); end

  # source://rack/2.2.4/lib/rack/request.rb#73
  def each_header(&block); end

  # source://rack/2.2.4/lib/rack/request.rb#48
  def env; end

  # source://rack/2.2.4/lib/rack/request.rb#68
  def fetch_header(name, &block); end

  # source://rack/2.2.4/lib/rack/request.rb#62
  def get_header(name); end

  # source://rack/2.2.4/lib/rack/request.rb#57
  def has_header?(name); end

  # source://rack/2.2.4/lib/rack/request.rb#78
  def set_header(name, v); end

  private

  # source://rack/2.2.4/lib/rack/request.rb#106
  def initialize_copy(other); end
end

module Rack::Request::Helpers
  # source://rack/2.2.4/lib/rack/request.rb#426
  def GET; end

  # source://rack/2.2.4/lib/rack/request.rb#440
  def POST; end

  # source://rack/2.2.4/lib/rack/request.rb#532
  def [](key); end

  # source://rack/2.2.4/lib/rack/request.rb#543
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/request.rb#519
  def accept_encoding; end

  # source://rack/2.2.4/lib/rack/request.rb#523
  def accept_language; end

  # source://rack/2.2.4/lib/rack/request.rb#227
  def authority; end

  # source://rack/2.2.4/lib/rack/request.rb#502
  def base_url; end

  # source://rack/2.2.4/lib/rack/request.rb#150
  def body; end

  # source://rack/2.2.4/lib/rack/request.rb#400
  def content_charset; end

  # source://rack/2.2.4/lib/rack/request.rb#159
  def content_length; end

  # source://rack/2.2.4/lib/rack/request.rb#271
  def content_type; end

  # source://rack/2.2.4/lib/rack/request.rb#256
  def cookies; end

  # source://rack/2.2.4/lib/rack/request.rb#181
  def delete?; end

  # source://rack/2.2.4/lib/rack/request.rb#497
  def delete_param(k); end

  # source://rack/2.2.4/lib/rack/request.rb#412
  def form_data?; end

  # source://rack/2.2.4/lib/rack/request.rb#344
  def forwarded_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#330
  def forwarded_for; end

  # source://rack/2.2.4/lib/rack/request.rb#338
  def forwarded_port; end

  # source://rack/2.2.4/lib/rack/request.rb#515
  def fullpath; end

  # source://rack/2.2.4/lib/rack/request.rb#184
  def get?; end

  # source://rack/2.2.4/lib/rack/request.rb#187
  def head?; end

  # source://rack/2.2.4/lib/rack/request.rb#296
  def host; end

  # source://rack/2.2.4/lib/rack/request.rb#281
  def host_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#285
  def host_with_port(authority = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/request.rb#304
  def hostname; end

  # source://rack/2.2.4/lib/rack/request.rb#354
  def ip; end

  # source://rack/2.2.4/lib/rack/request.rb#193
  def link?; end

  # source://rack/2.2.4/lib/rack/request.rb#160
  def logger; end

  # source://rack/2.2.4/lib/rack/request.rb#383
  def media_type; end

  # source://rack/2.2.4/lib/rack/request.rb#392
  def media_type_params; end

  # source://rack/2.2.4/lib/rack/request.rb#162
  def multithread?; end

  # source://rack/2.2.4/lib/rack/request.rb#190
  def options?; end

  # source://rack/2.2.4/lib/rack/request.rb#468
  def params; end

  # source://rack/2.2.4/lib/rack/request.rb#421
  def parseable_data?; end

  # source://rack/2.2.4/lib/rack/request.rb#196
  def patch?; end

  # source://rack/2.2.4/lib/rack/request.rb#511
  def path; end

  # source://rack/2.2.4/lib/rack/request.rb#154
  def path_info; end

  # source://rack/2.2.4/lib/rack/request.rb#155
  def path_info=(s); end

  # source://rack/2.2.4/lib/rack/request.rb#308
  def port; end

  # source://rack/2.2.4/lib/rack/request.rb#199
  def post?; end

  # source://rack/2.2.4/lib/rack/request.rb#202
  def put?; end

  # source://rack/2.2.4/lib/rack/request.rb#158
  def query_string; end

  # source://rack/2.2.4/lib/rack/request.rb#165
  def referer; end

  # source://rack/2.2.4/lib/rack/request.rb#165
  def referrer; end

  # source://rack/2.2.4/lib/rack/request.rb#157
  def request_method; end

  # source://rack/2.2.4/lib/rack/request.rb#210
  def scheme; end

  # source://rack/2.2.4/lib/rack/request.rb#151
  def script_name; end

  # source://rack/2.2.4/lib/rack/request.rb#152
  def script_name=(s); end

  # source://rack/2.2.4/lib/rack/request.rb#233
  def server_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#246
  def server_name; end

  # source://rack/2.2.4/lib/rack/request.rb#250
  def server_port; end

  # source://rack/2.2.4/lib/rack/request.rb#168
  def session; end

  # source://rack/2.2.4/lib/rack/request.rb#174
  def session_options; end

  # source://rack/2.2.4/lib/rack/request.rb#350
  def ssl?; end

  # source://rack/2.2.4/lib/rack/request.rb#205
  def trace?; end

  # source://rack/2.2.4/lib/rack/request.rb#527
  def trusted_proxy?(ip); end

  # source://rack/2.2.4/lib/rack/request.rb#208
  def unlink?; end

  # source://rack/2.2.4/lib/rack/request.rb#477
  def update_param(k, v); end

  # source://rack/2.2.4/lib/rack/request.rb#507
  def url; end

  # source://rack/2.2.4/lib/rack/request.rb#161
  def user_agent; end

  # source://rack/2.2.4/lib/rack/request.rb#552
  def values_at(*keys); end

  # source://rack/2.2.4/lib/rack/request.rb#276
  def xhr?; end

  private

  # source://rack/2.2.4/lib/rack/request.rb#641
  def allowed_scheme(header); end

  # source://rack/2.2.4/lib/rack/request.rb#558
  def default_session; end

  # source://rack/2.2.4/lib/rack/request.rb#645
  def extract_proto_header(header); end

  # source://rack/2.2.4/lib/rack/request.rb#636
  def forwarded_scheme; end

  # source://rack/2.2.4/lib/rack/request.rb#574
  def parse_http_accept_header(header); end

  # source://rack/2.2.4/lib/rack/request.rb#593
  def parse_multipart; end

  # source://rack/2.2.4/lib/rack/request.rb#589
  def parse_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/request.rb#585
  def query_parser; end

  # source://rack/2.2.4/lib/rack/request.rb#632
  def reject_trusted_ip_addresses(ip_addresses); end

  # source://rack/2.2.4/lib/rack/request.rb#619
  def split_authority(authority); end

  # source://rack/2.2.4/lib/rack/request.rb#597
  def split_header(value); end

  # source://rack/2.2.4/lib/rack/request.rb#561
  def wrap_ipv6(host); end
end

# source://rack/2.2.4/lib/rack/request.rb#130
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/request.rb#115
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/request.rb#133
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#136
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#145
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#142
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#139
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#148
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#123
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/request.rb#21
Rack::Request::SCHEME_WHITELIST = T.let(T.unsafe(nil), Array)

class Rack::Response
  include ::Rack::Response::Helpers

  # source://rack/2.2.4/lib/rack/response.rb#42
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#127
  def [](key); end

  # source://rack/2.2.4/lib/rack/response.rb#128
  def []=(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def body; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def body=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#73
  def chunked?; end

  # source://rack/2.2.4/lib/rack/response.rb#118
  def close; end

  # source://rack/2.2.4/lib/rack/response.rb#129
  def delete_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#98
  def each(&callback); end

  # source://rack/2.2.4/lib/rack/response.rb#122
  def empty?; end

  # source://rack/2.2.4/lib/rack/response.rb#80
  def finish(&block); end

  # source://rack/2.2.4/lib/rack/response.rb#127
  def get_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#126
  def has_header?(key); end

  # source://rack/2.2.4/lib/rack/response.rb#27
  def header; end

  # source://rack/2.2.4/lib/rack/response.rb#27
  def headers; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def length; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def length=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#68
  def redirect(target, status = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#128
  def set_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def status; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def status=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#80
  def to_a(&block); end

  # source://rack/2.2.4/lib/rack/response.rb#112
  def write(chunk); end

  class << self
    # source://rack/2.2.4/lib/rack/response.rb#19
    def [](status, headers, body); end
  end
end

# source://rack/2.2.4/lib/rack/response.rb#23
Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

module Rack::Response::Helpers
  # source://rack/2.2.4/lib/rack/response.rb#145
  def accepted?; end

  # source://rack/2.2.4/lib/rack/response.rb#171
  def add_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#148
  def bad_request?; end

  # source://rack/2.2.4/lib/rack/response.rb#246
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#229
  def cache_control; end

  # source://rack/2.2.4/lib/rack/response.rb#233
  def cache_control=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#140
  def client_error?; end

  # source://rack/2.2.4/lib/rack/response.rb#199
  def content_length; end

  # source://rack/2.2.4/lib/rack/response.rb#182
  def content_type; end

  # source://rack/2.2.4/lib/rack/response.rb#187
  def content_type=(content_type); end

  # source://rack/2.2.4/lib/rack/response.rb#144
  def created?; end

  # source://rack/2.2.4/lib/rack/response.rb#217
  def delete_cookie(key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#238
  def do_not_cache!; end

  # source://rack/2.2.4/lib/rack/response.rb#253
  def etag; end

  # source://rack/2.2.4/lib/rack/response.rb#257
  def etag=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#150
  def forbidden?; end

  # source://rack/2.2.4/lib/rack/response.rb#158
  def include?(header); end

  # source://rack/2.2.4/lib/rack/response.rb#137
  def informational?; end

  # source://rack/2.2.4/lib/rack/response.rb#135
  def invalid?; end

  # source://rack/2.2.4/lib/rack/response.rb#204
  def location; end

  # source://rack/2.2.4/lib/rack/response.rb#208
  def location=(location); end

  # source://rack/2.2.4/lib/rack/response.rb#191
  def media_type; end

  # source://rack/2.2.4/lib/rack/response.rb#195
  def media_type_params; end

  # source://rack/2.2.4/lib/rack/response.rb#152
  def method_not_allowed?; end

  # source://rack/2.2.4/lib/rack/response.rb#147
  def moved_permanently?; end

  # source://rack/2.2.4/lib/rack/response.rb#146
  def no_content?; end

  # source://rack/2.2.4/lib/rack/response.rb#151
  def not_found?; end

  # source://rack/2.2.4/lib/rack/response.rb#143
  def ok?; end

  # source://rack/2.2.4/lib/rack/response.rb#153
  def precondition_failed?; end

  # source://rack/2.2.4/lib/rack/response.rb#156
  def redirect?; end

  # source://rack/2.2.4/lib/rack/response.rb#139
  def redirection?; end

  # source://rack/2.2.4/lib/rack/response.rb#141
  def server_error?; end

  # source://rack/2.2.4/lib/rack/response.rb#212
  def set_cookie(key, value); end

  # source://rack/2.2.4/lib/rack/response.rb#221
  def set_cookie_header; end

  # source://rack/2.2.4/lib/rack/response.rb#225
  def set_cookie_header=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#138
  def successful?; end

  # source://rack/2.2.4/lib/rack/response.rb#149
  def unauthorized?; end

  # source://rack/2.2.4/lib/rack/response.rb#154
  def unprocessable?; end

  protected

  # source://rack/2.2.4/lib/rack/response.rb#287
  def append(chunk); end

  # source://rack/2.2.4/lib/rack/response.rb#263
  def buffered_body!; end
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # source://rack/2.2.4/lib/rack/response.rb#307
  def initialize(status, headers); end

  # source://rack/2.2.4/lib/rack/response.rb#315
  def delete_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#313
  def get_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#312
  def has_header?(key); end

  # source://rack/2.2.4/lib/rack/response.rb#304
  def headers; end

  # source://rack/2.2.4/lib/rack/response.rb#314
  def set_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#305
  def status; end

  # source://rack/2.2.4/lib/rack/response.rb#305
  def status=(_arg0); end
end

# source://rack/2.2.4/lib/rack/response.rb#24
Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

class Rack::RewindableInput
  # source://rack/2.2.4/lib/rack/rewindable_input.rb#17
  def initialize(io); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#48
  def close; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#33
  def each(&block); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#23
  def gets; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#28
  def read(*args); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#38
  def rewind; end

  private

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#90
  def filesystem_has_posix_semantics?; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#61
  def make_rewindable; end
end

class Rack::Runtime
  # source://rack/2.2.4/lib/rack/runtime.rb#14
  def initialize(app, name = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/runtime.rb#20
  def call(env); end
end

# source://rack/2.2.4/lib/rack/runtime.rb#11
Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/runtime.rb#12
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#24
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#27
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#28
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#26
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#33
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

class Rack::Sendfile
  # source://rack/2.2.4/lib/rack/sendfile.rb#101
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/sendfile.rb#109
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/sendfile.rb#149
  def map_accel_path(env, path); end

  # source://rack/2.2.4/lib/rack/sendfile.rb#143
  def variation(env); end
end

class Rack::Server
  # source://rack/2.2.4/lib/rack/server.rb#215
  def initialize(options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/server.rb#248
  def app; end

  # source://rack/2.2.4/lib/rack/server.rb#234
  def default_options; end

  # source://rack/2.2.4/lib/rack/server.rb#282
  def middleware; end

  # source://rack/2.2.4/lib/rack/server.rb#229
  def options; end

  # source://rack/2.2.4/lib/rack/server.rb#171
  def options=(_arg0); end

  # source://rack/2.2.4/lib/rack/server.rb#330
  def server; end

  # source://rack/2.2.4/lib/rack/server.rb#286
  def start(&block); end

  private

  # source://rack/2.2.4/lib/rack/server.rb#411
  def build_app(app); end

  # source://rack/2.2.4/lib/rack/server.rb#344
  def build_app_and_options_from_config; end

  # source://rack/2.2.4/lib/rack/server.rb#392
  def build_app_from_string; end

  # source://rack/2.2.4/lib/rack/server.rb#440
  def check_pid!; end

  # source://rack/2.2.4/lib/rack/server.rb#425
  def daemonize_app; end

  # source://rack/2.2.4/lib/rack/server.rb#354
  def handle_profiling(heapfile, profile_mode, filename); end

  # source://rack/2.2.4/lib/rack/server.rb#382
  def make_profile_name(filename); end

  # source://rack/2.2.4/lib/rack/server.rb#407
  def opt_parser; end

  # source://rack/2.2.4/lib/rack/server.rb#396
  def parse_options(args); end

  # source://rack/2.2.4/lib/rack/server.rb#450
  def pidfile_process_status; end

  # source://rack/2.2.4/lib/rack/server.rb#421
  def wrapped_app; end

  # source://rack/2.2.4/lib/rack/server.rb#432
  def write_pid; end

  class << self
    # source://rack/2.2.4/lib/rack/server.rb#259
    def default_middleware_by_environment; end

    # source://rack/2.2.4/lib/rack/server.rb#253
    def logging_middleware; end

    # source://rack/2.2.4/lib/rack/server.rb#277
    def middleware; end

    # source://rack/2.2.4/lib/rack/server.rb#167
    def start(options = T.unsafe(nil)); end
  end
end

class Rack::Server::Options
  # source://rack/2.2.4/lib/rack/server.rb#127
  def handler_opts(options); end

  # source://rack/2.2.4/lib/rack/server.rb#12
  def parse!(args); end
end

module Rack::Session; end
module Rack::Session::Abstract; end

class Rack::Session::Abstract::ID < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#517
  def delete_session(req, sid, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#502
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#510
  def write_session(req, sid, session, options); end

  class << self
    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#488
    def inherited(klass); end
  end
end

class Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#250
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#259
  def call(env); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#373
  def commit_session(req, res); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#263
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def default_options; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def key; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def sid_secure; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#342
  def commit_session?(req, session, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#408
  def cookie_value(data); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#328
  def current_session_id(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#448
  def delete_session(req, sid, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#320
  def extract_session_id(request); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#433
  def find_session(env, sid); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#359
  def force_options?(options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#355
  def forced_session_update?(session, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#288
  def generate_sid(secure = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#278
  def initialize_sid; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#312
  def load_session(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#351
  def loaded_session?(session); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#274
  def make_request(env); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#301
  def prepare_session(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#363
  def security_matches?(request, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#424
  def session_class; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#334
  def session_exists?(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#415
  def set_cookie(request, res, cookie); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#441
  def write_session(req, sid, session, options); end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#234
Rack::Session::Abstract::Persisted::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::PersistedSecure < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#471
  def extract_session_id(*_arg0); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#465
  def generate_sid(*_arg0); end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#482
  def cookie_value(data); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#478
  def session_class; end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < ::Rack::Session::Abstract::SessionHash
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#455
  def [](key); end
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#62
  def initialize(store, req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#82
  def [](key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#108
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#114
  def clear; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#140
  def delete(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#119
  def destroy; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#87
  def dig(key, *keys); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#77
  def each(&block); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#163
  def empty?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#153
  def exists?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#92
  def fetch(key, default = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def has_key?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#68
  def id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#46
  def id=(_arg0); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def include?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#145
  def inspect; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def key?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#168
  def keys; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#159
  def loaded?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#129
  def merge!(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#73
  def options; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#135
  def replace(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#108
  def store(key, value); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#124
  def to_hash; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#129
  def update(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#173
  def values; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#188
  def load!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#180
  def load_for_read!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#184
  def load_for_write!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#194
  def stringify_keys(other); end

  class << self
    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#50
    def find(req); end

    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#54
    def set(req, session); end

    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#58
    def set_options(req, options); end
  end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#48
Rack::Session::Abstract::SessionHash::Unspecified = T.let(T.unsafe(nil), Object)

class Rack::Session::Cookie < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.4/lib/rack/session/cookie.rb#107
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#105
  def coder; end

  private

  # source://rack/2.2.4/lib/rack/session/cookie.rb#180
  def delete_session(req, session_id, options); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#185
  def digest_match?(data, digest); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#132
  def extract_session_id(request); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#126
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#192
  def generate_hmac(data, secret); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#149
  def persistent_session_id!(data, sid = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#196
  def secure?(options); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#136
  def unpacked_cookie_data(request); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#164
  def write_session(req, session_id, session, options); end
end

class Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#56
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#52
  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#79
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#75
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#66
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#62
  def encode(str); end
end

class Rack::Session::Cookie::Base64::ZipJSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#90
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#86
  def encode(obj); end
end

class Rack::Session::Cookie::Identity
  # source://rack/2.2.4/lib/rack/session/cookie.rb#102
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#101
  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  # source://rack/2.2.4/lib/rack/session/cookie.rb#158
  def initialize(session_id, cookie_value); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#156
  def cookie_value; end
end

class Rack::Session::Pool < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.4/lib/rack/session/pool.rb#33
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#63
  def delete_session(req, session_id, options); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#46
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#39
  def generate_sid; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#30
  def mutex; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#30
  def pool; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#71
  def with_lock(req); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#56
  def write_session(req, session_id, new_session, options); end

  private

  # source://rack/2.2.4/lib/rack/session/pool.rb#80
  def get_session_with_fallback(sid); end
end

# source://rack/2.2.4/lib/rack/session/pool.rb#31
Rack::Session::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::SessionId
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#20
  def initialize(public_id); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def cookie_value; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#31
  def empty?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#32
  def inspect; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#24
  def private_id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def public_id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def to_s; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#36
  def hash_sid(sid); end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#16
Rack::Session::SessionId::ID_VERSION = T.let(T.unsafe(nil), Integer)

class Rack::ShowExceptions
  # source://rack/2.2.4/lib/rack/show_exceptions.rb#18
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#22
  def call(env); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#57
  def dump_exception(exception); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#103
  def h(obj); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#48
  def prefers_plaintext?(env); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#63
  def pretty(env, exception); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#99
  def template; end

  private

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#52
  def accepts_html?(env); end
end

# source://rack/2.2.4/lib/rack/show_exceptions.rb#16
Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)

# source://rack/2.2.4/lib/rack/show_exceptions.rb#118
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

class Rack::ShowStatus
  # source://rack/2.2.4/lib/rack/show_status.rb#14
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/show_status.rb#19
  def call(env); end

  # source://rack/2.2.4/lib/rack/show_status.rb#44
  def h(obj); end
end

# source://rack/2.2.4/lib/rack/show_status.rb#59
Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

class Rack::Static
  # source://rack/2.2.4/lib/rack/static.rb#91
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/static.rb#107
  def add_index_root?(path); end

  # source://rack/2.2.4/lib/rack/static.rb#166
  def applicable_rules(path); end

  # source://rack/2.2.4/lib/rack/static.rb#123
  def call(env); end

  # source://rack/2.2.4/lib/rack/static.rb#119
  def can_serve(path); end

  # source://rack/2.2.4/lib/rack/static.rb#111
  def overwrite_file_path(path); end

  # source://rack/2.2.4/lib/rack/static.rb#115
  def route_file(path); end
end

# source://rack/2.2.4/lib/rack.rb#48
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#34
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

class Rack::TempfileReaper
  # source://rack/2.2.4/lib/rack/tempfile_reaper.rb#9
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/tempfile_reaper.rb#13
  def call(env); end
end

module Rack::Test
  class << self
    # Whether the version of rack in use handles encodings.
    #
    # @return [Boolean]
    #
    # source://rack-test//lib/rack/test.rb#407
    def encoding_aware_strings?; end
  end
end

# Represents individual cookies in the cookie jar.  This is considered private
# API and behavior of this class can change at any time.
class Rack::Test::Cookie
  include ::Rack::Utils

  # @return [Cookie] a new instance of Cookie
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#23
  def initialize(raw, uri = T.unsafe(nil), default_host = T.unsafe(nil)); end

  # Order cookies by name, path, and domain.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#107
  def <=>(other); end

  # The explicit or implicit domain for the cookie.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#58
  def domain; end

  # Whether the cookie has a value.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#53
  def empty?; end

  # Whether the cookie is currently expired.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#85
  def expired?; end

  # A Time value for when the cookie expires, if the expires option is set.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#80
  def expires; end

  # Whether the cookie has the httponly flag, indicating it is not available via
  # a javascript API.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#70
  def http_only?; end

  # Cookies that do not match the URI will not be sent in requests to the URI.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#102
  def matches?(uri); end

  # The name of the cookie, will be a string
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#14
  def name; end

  # The explicit or implicit path for the cookie.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#75
  def path; end

  # The raw string for the cookie, without options. Will generally be in
  # name=value format is name and value are provided.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#21
  def raw; end

  # Wether the given cookie can replace the current cookie in the cookie jar.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#48
  def replaces?(other); end

  # Whether the cookie has the secure flag, indicating it can only be sent over
  # an encrypted connection.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#64
  def secure?; end

  # A hash of cookie options, including the cookie value, but excluding the cookie name.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#112
  def to_h; end

  # A hash of cookie options, including the cookie value, but excluding the cookie name.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#112
  def to_hash; end

  # Whether the cookie is valid for the given URI.
  #
  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#90
  def valid?(uri); end

  # The value of the cookie, will be a string or nil if there is no value.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#17
  def value; end

  private

  # The default URI to use for the cookie, including just the host.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#124
  def default_uri; end
end

# Represents all cookies for a session, handling adding and
# removing cookies, and finding which cookies apply to a given
# request.  This is considered private API and behavior of this
# class can change at any time.
class Rack::Test::CookieJar
  # @return [CookieJar] a new instance of CookieJar
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#136
  def initialize(cookies = T.unsafe(nil), default_host = T.unsafe(nil)); end

  # Add a Cookie to the cookie jar.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#192
  def <<(new_cookie); end

  # Return the value for first cookie with the given name, or nil
  # if no such cookie exists.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#143
  def [](name); end

  # Set a cookie with the given name and value in the
  # cookie jar.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#153
  def []=(name, value); end

  # Delete all cookies with the given name from the cookie jar.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#167
  def delete(name); end

  # Return a raw cookie string for the cookie header to
  # use for the given URI.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#203
  def for(uri); end

  # Return the first cookie with the given name, or nil if
  # no such cookie exists.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#159
  def get_cookie(name); end

  # Add a string of raw cookie information to the cookie jar,
  # if the cookie is valid for the given URI.
  # Cookies should be separated with a newline.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#177
  def merge(raw_cookies, uri = T.unsafe(nil)); end

  # Return a hash cookie names and cookie values for cookies in the jar.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#220
  def to_hash; end

  private

  # Yield each cookie that matches for the URI.
  #
  # The cookies are sorted by most specific first. So, we loop through
  # all the cookies in order and add it to a hash by cookie name if
  # the cookie can be sent to the current URI. It's added to the hash
  # so that when we are done, the cookies will be unique by name and
  # we'll have grabbed the most specific to the URI.
  #
  # source://rack-test//lib/rack/test/cookie_jar.rb#239
  def each_cookie_for(uri); end
end

# source://rack-test//lib/rack/test/cookie_jar.rb#134
Rack::Test::CookieJar::DELIMITER = T.let(T.unsafe(nil), String)

# The default host to use for requests, when a full URI is not
# provided.
#
# source://rack-test//lib/rack/test.rb#33
Rack::Test::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# The ending boundary in multipart requests
#
# source://rack-test//lib/rack/test.rb#42
Rack::Test::END_BOUNDARY = T.let(T.unsafe(nil), String)

# The common base class for exceptions raised by Rack::Test
class Rack::Test::Error < ::StandardError; end

# The default multipart boundary to use for multipart request bodies
#
# source://rack-test//lib/rack/test.rb#36
Rack::Test::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# This module serves as the primary integration point for using Rack::Test
# in a testing environment. It depends on an app method being defined in the
# same context, and provides the Rack::Test API methods (see Rack::Test::Session
# for their documentation). It defines the following methods that are delegated
# to the current session: :request, :get, :post, :put, :patch, :delete, :options,
# :head, :custom_request, :follow_redirect!, :header, :env, :set_cookie,
# :clear_cookies, :authorize, :basic_authorize, :last_response, and :last_request.
#
# Example:
#
#   class HomepageTest < Test::Unit::TestCase
#     include Rack::Test::Methods
#
#     def app
#       MyApp
#     end
#   end
module Rack::Test::Methods
  extend ::Forwardable

  # Private accessor to avoid uninitialized instance variable warning in Ruby 2.*
  #
  # source://rack-test//lib/rack/test/methods.rb#91
  def _rack_test_current_session=(_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def authorize(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def basic_authorize(*args, **_arg1, &block); end

  # Create a new Rack::Test::Session for #app.
  #
  # source://rack-test//lib/rack/test/methods.rb#40
  def build_rack_test_session(_name); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def clear_cookies(*args, **_arg1, &block); end

  # Return the currently actively session.  This is the session to
  # which the delegated methods are sent.
  #
  # source://rack-test//lib/rack/test/methods.rb#51
  def current_session; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def custom_request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete(*args, **_arg1, &block); end

  # source://rack-test//lib/rack/test/methods.rb#64
  def digest_authorize(username, password); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def env(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def follow_redirect!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def get(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def head(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def header(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last_request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last_response(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def options(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def patch(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def post(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def put(*args, **_arg1, &block); end

  # Return the existing session with the given name, or a new
  # rack session.  Always use a new session if name is nil.
  # For backwards compatibility with older rack-test versions.
  #
  # source://rack-test//lib/rack/test/methods.rb#29
  def rack_mock_session(name = T.unsafe(nil)); end

  # Return the existing session with the given name, or a new
  # rack session.  Always use a new session if name is nil.
  #
  # source://rack-test//lib/rack/test/methods.rb#29
  def rack_test_session(name = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def set_cookie(*args, **_arg1, &block); end

  # Create a new session (or reuse an existing session with the given name),
  # and make it the current session for the given block.
  #
  # source://rack-test//lib/rack/test/methods.rb#57
  def with_session(name); end

  private

  # Private accessor to avoid uninitialized instance variable warning in Ruby 2.*
  #
  # source://rack-test//lib/rack/test/methods.rb#91
  def _rack_test_current_session; end
end

# The starting boundary in multipart requests
#
# source://rack-test//lib/rack/test.rb#39
Rack::Test::START_BOUNDARY = T.let(T.unsafe(nil), String)

# Rack::Test::Session handles a series of requests issued to a Rack app.
# It keeps track of the cookies for the session, and allows for setting headers
# and a default rack environment that is used for future requests.
#
# Rack::Test::Session's methods are most often called through Rack::Test::Methods,
# which will automatically build a session when it's first used.
class Rack::Test::Session
  include ::Rack::Utils
  include ::Rack::Test::Utils
  extend ::Forwardable

  # Creates a Rack::Test::Session for a given Rack app or Rack::Test::BasicSession.
  #
  # Note: Generally, you won't need to initialize a Rack::Test::Session directly.
  # Instead, you should include Rack::Test::Methods into your testing context.
  # (See README.rdoc for an example)
  #
  # The following methods are defined via metaprogramming: get, post, put, patch,
  # delete, options, and head. Each method submits a request with the given request
  # method, with the given URI and optional parameters and rack environment.
  # Examples:
  #
  #   # URI only:
  #   get("/")                   # GET /
  #   get("/?foo=bar")           # GET /?foo=bar
  #
  #   # URI and parameters
  #   get("/foo", 'bar'=>'baz')  # GET /foo?bar=baz
  #   post("/foo", 'bar'=>'baz') # POST /foo (bar=baz in request body)
  #
  #   # URI, parameters, and rack environment
  #   get("/bar", {}, 'CONTENT_TYPE'=>'foo')
  #   get("/bar", {'foo'=>'baz'}, 'HTTP_ACCEPT'=>'*')
  #
  # The above methods as well as #request and #custom_request store the Rack::Request
  # submitted in #last_request. The methods store a Rack::MockResponse based on the
  # response in #last_response. #last_response is also returned by the methods.
  # If a block is given, #last_response is also yielded to the block.
  #
  # @return [Session] a new instance of Session
  #
  # source://rack-test//lib/rack/test.rb#99
  def initialize(app, default_host = T.unsafe(nil)); end

  # source://rack-test//lib/rack/test.rb#217
  def _digest_authorize(username, password); end

  # Run a block after the each request completes.
  #
  # source://rack-test//lib/rack/test.rb#120
  def after_request(&block); end

  # Set the username and password for HTTP Basic authorization, to be
  # included in subsequent requests in the HTTP_AUTHORIZATION header.
  #
  # Example:
  #   basic_authorize "bryan", "secret"
  #
  # source://rack-test//lib/rack/test.rb#200
  def authorize(username, password); end

  # Set the username and password for HTTP Basic authorization, to be
  # included in subsequent requests in the HTTP_AUTHORIZATION header.
  #
  # Example:
  #   basic_authorize "bryan", "secret"
  #
  # source://rack-test//lib/rack/test.rb#200
  def basic_authorize(username, password); end

  # Replace the current cookie jar with an empty cookie jar.
  #
  # source://rack-test//lib/rack/test.rb#125
  def clear_cookies; end

  # The Rack::Test::CookieJar for the cookies for the current session.
  #
  # source://rack-test//lib/rack/test.rb#67
  def cookie_jar; end

  # The Rack::Test::CookieJar for the cookies for the current session.
  #
  # source://rack-test//lib/rack/test.rb#67
  def cookie_jar=(_arg0); end

  # Issue a request using the given HTTP verb for the given URI, with optional
  # params and rack environment.  Example:
  #
  #   custom_request "LINK", "/"
  #
  # source://rack-test//lib/rack/test.rb#162
  def custom_request(verb, uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # The default host used for the session for when using paths for URIs.
  #
  # source://rack-test//lib/rack/test.rb#70
  def default_host; end

  # source://rack-test//lib/rack/test.rb#113
  def delete(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # Set the username and password for HTTP Digest authorization, to be
  # included in subsequent requests in the HTTP_AUTHORIZATION header.
  # This method is deprecated and will be removed in rack-test 2.1
  #
  # Example:
  #   digest_authorize "bryan", "secret"
  #
  # source://rack-test//lib/rack/test.rb#213
  def digest_authorize(username, password); end

  # Set an entry in the rack environment to be included on all subsequent
  # requests through the session. Use a value of nil to remove a previously
  # value.  Example:
  #
  #   env "rack.session", {:csrf => 'token'}
  #
  # source://rack-test//lib/rack/test.rb#187
  def env(name, value); end

  # Rack::Test will not follow any redirects automatically. This method
  # will follow the redirect returned (including setting the Referer header
  # on the new request) in the last response. If the last response was not
  # a redirect, an error will be raised.
  #
  # source://rack-test//lib/rack/test.rb#226
  def follow_redirect!; end

  # source://rack-test//lib/rack/test.rb#113
  def get(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test//lib/rack/test.rb#113
  def head(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # Set a header to be included on all subsequent requests through the
  # session. Use a value of nil to remove a previously configured header.
  #
  # In accordance with the Rack spec, headers will be included in the Rack
  # environment hash in HTTP_USER_AGENT form.  Example:
  #
  #   header "user-agent", "Firefox"
  #
  # source://rack-test//lib/rack/test.rb#175
  def header(name, value); end

  # Return the last request issued in the session. Raises an error if no
  # requests have been sent yet.
  #
  # @raise [Error]
  #
  # source://rack-test//lib/rack/test.rb#136
  def last_request; end

  # Return the last response received in the session. Raises an error if
  # no requests have been sent yet.
  #
  # @raise [Error]
  #
  # source://rack-test//lib/rack/test.rb#143
  def last_response; end

  # source://rack-test//lib/rack/test.rb#113
  def options(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test//lib/rack/test.rb#113
  def patch(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test//lib/rack/test.rb#113
  def post(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test//lib/rack/test.rb#113
  def put(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # Issue a request to the Rack app for the given URI and optional Rack
  # environment.  Example:
  #
  #   request "/"
  #
  # source://rack-test//lib/rack/test.rb#152
  def request(uri, env = T.unsafe(nil), &block); end

  # Set a cookie in the current cookie jar.
  #
  # source://rack-test//lib/rack/test.rb#130
  def set_cookie(cookie, uri = T.unsafe(nil)); end

  private

  # Append a string version of the query params to the array of query params.
  #
  # source://rack-test//lib/rack/test.rb#338
  def append_query_params(query_array, query_params); end

  # close() gets called automatically in newer Rack versions.
  #
  # source://rack-test//lib/rack/test.rb#264
  def close_body(body); end

  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test.rb#401
  def digest_auth_configured?; end

  # source://rack-test//lib/rack/test.rb#378
  def digest_auth_header; end

  # Update environment to use based on given URI.
  #
  # source://rack-test//lib/rack/test.rb#291
  def env_for(uri, env); end

  # Return the multipart content type to use based on the environment.
  #
  # source://rack-test//lib/rack/test.rb#344
  def multipart_content_type(env); end

  # Normalize URI based on given URI/path and environment.
  #
  # source://rack-test//lib/rack/test.rb#269
  def parse_uri(path, env); end

  # Submit the request with the given URI and rack environment to
  # the mock session.  Returns and potentially yields the last response.
  #
  # source://rack-test//lib/rack/test.rb#355
  def process_request(uri, env); end

  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test.rb#395
  def retry_with_digest_auth?(env); end

  class << self
    # source://rack-test//lib/rack/test.rb#57
    def new(app, default_host = T.unsafe(nil)); end
  end
end

# source://rack-test//lib/rack/test.rb#277
Rack::Test::Session::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

# Wraps a Tempfile with a content type. Including one or more UploadedFile's
# in the params causes Rack::Test to build and issue a multipart request.
#
# Example:
#   post "/photos", "file" => Rack::Test::UploadedFile.new("me.jpg", "image/jpeg")
class Rack::Test::UploadedFile
  # Creates a new UploadedFile instance.
  #
  # Arguments:
  # content :: is a path to a file, or an {IO} or {StringIO} object representing the content.
  # content_type :: MIME type of the file
  # binary :: Whether the file should be set to binmode (content treated as binary).
  # original_filename :: The filename to use for the file if +content+ is a StringIO.
  #
  # @return [UploadedFile] a new instance of UploadedFile
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#31
  def initialize(content, content_type = T.unsafe(nil), binary = T.unsafe(nil), original_filename: T.unsafe(nil)); end

  # Append to given buffer in 64K chunks to avoid multiple large
  # copies of file data in memory.  Rewind tempfile before and
  # after to make sure all data in tempfile is appended to the
  # buffer.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#58
  def append_to(buffer); end

  # The content type of the "uploaded" file
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#22
  def content_type; end

  # The content type of the "uploaded" file
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#22
  def content_type=(_arg0); end

  # The path to the tempfile. Will not work if the receiver's content is from a StringIO.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#44
  def local_path; end

  # Delegate all methods not handled to the tempfile.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#50
  def method_missing(method_name, *args, &block); end

  # The filename, *not* including the path, of the "uploaded" file
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#16
  def original_filename; end

  # The path to the tempfile. Will not work if the receiver's content is from a StringIO.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#44
  def path; end

  # The tempfile
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#19
  def tempfile; end

  private

  # Create a tempfile and copy the content from the given path into the tempfile.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#94
  def initialize_from_file_path(path); end

  # Use the StringIO as the tempfile.
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#88
  def initialize_from_stringio(stringio, original_filename); end

  # @return [Boolean]
  #
  # source://rack-test//lib/rack/test/uploaded_file.rb#69
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # Close and unlink the given file, used as a finalizer for the tempfile,
    # if the tempfile is backed by a file in the filesystem.
    #
    # source://rack-test//lib/rack/test/uploaded_file.rb#80
    def actually_finalize(file); end

    # A proc that can be used as a finalizer to close and unlink the tempfile.
    #
    # source://rack-test//lib/rack/test/uploaded_file.rb#74
    def finalize(file); end
  end
end

module Rack::Test::Utils
  include ::Rack::Utils
  extend ::Rack::Utils
  extend ::Rack::Test::Utils

  # Build a multipart body for the given params.
  #
  # @raise [ArgumentError]
  #
  # source://rack-test//lib/rack/test/utils.rb#34
  def build_multipart(params, _first = T.unsafe(nil), multipart = T.unsafe(nil)); end

  # Build a query string for the given value and prefix. The value
  # can be an array or hash of parameters.
  #
  # source://rack-test//lib/rack/test/utils.rb#11
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  private

  # Append each multipart parameter value to the buffer.
  #
  # source://rack-test//lib/rack/test/utils.rb#100
  def _build_parts(buffer, parameters); end

  # Append the multipart fragment for a parameter that is a file upload to the buffer.
  #
  # source://rack-test//lib/rack/test/utils.rb#133
  def build_file_part(buffer, parameter_name, uploaded_file); end

  # Build the multipart content for uploading.
  #
  # source://rack-test//lib/rack/test/utils.rb#94
  def build_parts(buffer, parameters); end

  # Append the multipart fragment for a parameter that isn't a file upload to the buffer.
  #
  # source://rack-test//lib/rack/test/utils.rb#121
  def build_primitive_part(buffer, parameter_name, value); end

  # Return a flattened hash of parameter values based on the given params.
  #
  # source://rack-test//lib/rack/test/utils.rb#62
  def normalize_multipart_params(params, first = T.unsafe(nil)); end
end

# source://rack-test//lib/rack/test/version.rb#3
Rack::Test::VERSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#47
Rack::UNLINK = T.let(T.unsafe(nil), String)

class Rack::URLMap
  # source://rack/2.2.4/lib/rack/urlmap.rb#19
  def initialize(map = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/urlmap.rb#46
  def call(env); end

  # source://rack/2.2.4/lib/rack/urlmap.rb#23
  def remap(map); end

  private

  # source://rack/2.2.4/lib/rack/urlmap.rb#85
  def casecmp?(v1, v2); end
end

module Rack::Utils
  private

  # source://rack/2.2.4/lib/rack/utils.rb#226
  def add_cookie_to_header(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#309
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#148
  def best_q_match(q_value_header, available_mimes); end

  # source://rack/2.2.4/lib/rack/utils.rb#115
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#105
  def build_query(params); end

  # source://rack/2.2.4/lib/rack/utils.rb#341
  def byte_ranges(env, size); end

  # source://rack/2.2.4/lib/rack/utils.rb#594
  def clean_path_info(path_info); end

  # source://rack/2.2.4/lib/rack/utils.rb#86
  def clock_time; end

  # source://rack/2.2.4/lib/rack/utils.rb#302
  def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#38
  def escape(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#173
  def escape_html(string); end

  # source://rack/2.2.4/lib/rack/utils.rb#44
  def escape_path(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#346
  def get_byte_ranges(http_range, size); end

  # source://rack/2.2.4/lib/rack/utils.rb#272
  def make_delete_cookie_header(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#209
  def parse_cookies(env); end

  # source://rack/2.2.4/lib/rack/utils.rb#213
  def parse_cookies_header(header); end

  # source://rack/2.2.4/lib/rack/utils.rb#101
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#97
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://rack/2.2.4/lib/rack/utils.rb#133
  def q_values(q_value_header); end

  # source://rack/2.2.4/lib/rack/utils.rb#332
  def rfc2109(time); end

  # source://rack/2.2.4/lib/rack/utils.rb#319
  def rfc2822(time); end

  # source://rack/2.2.4/lib/rack/utils.rb#380
  def secure_compare(a, b); end

  # source://rack/2.2.4/lib/rack/utils.rb#177
  def select_best_encoding(available_encodings, accept_encoding); end

  # source://rack/2.2.4/lib/rack/utils.rb#267
  def set_cookie_header!(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#584
  def status_code(status); end

  # source://rack/2.2.4/lib/rack/utils.rb#56
  def unescape(s, encoding = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#50
  def unescape_path(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#611
  def valid_path?(path); end

  class << self
    # source://rack/2.2.4/lib/rack/utils.rb#226
    def add_cookie_to_header(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#309
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#148
    def best_q_match(q_value_header, available_mimes); end

    # source://rack/2.2.4/lib/rack/utils.rb#115
    def build_nested_query(value, prefix = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#105
    def build_query(params); end

    # source://rack/2.2.4/lib/rack/utils.rb#341
    def byte_ranges(env, size); end

    # source://rack/2.2.4/lib/rack/utils.rb#594
    def clean_path_info(path_info); end

    # source://rack/2.2.4/lib/rack/utils.rb#86
    def clock_time; end

    # source://rack/2.2.4/lib/rack/utils.rb#29
    def default_query_parser; end

    # source://rack/2.2.4/lib/rack/utils.rb#29
    def default_query_parser=(_arg0); end

    # source://rack/2.2.4/lib/rack/utils.rb#302
    def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#38
    def escape(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#173
    def escape_html(string); end

    # source://rack/2.2.4/lib/rack/utils.rb#44
    def escape_path(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#346
    def get_byte_ranges(http_range, size); end

    # source://rack/2.2.4/lib/rack/utils.rb#77
    def key_space_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#81
    def key_space_limit=(v); end

    # source://rack/2.2.4/lib/rack/utils.rb#272
    def make_delete_cookie_header(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#61
    def multipart_part_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#61
    def multipart_part_limit=(_arg0); end

    # source://rack/2.2.4/lib/rack/utils.rb#69
    def param_depth_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#73
    def param_depth_limit=(v); end

    # source://rack/2.2.4/lib/rack/utils.rb#209
    def parse_cookies(env); end

    # source://rack/2.2.4/lib/rack/utils.rb#213
    def parse_cookies_header(header); end

    # source://rack/2.2.4/lib/rack/utils.rb#101
    def parse_nested_query(qs, d = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#97
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://rack/2.2.4/lib/rack/utils.rb#133
    def q_values(q_value_header); end

    # source://rack/2.2.4/lib/rack/utils.rb#332
    def rfc2109(time); end

    # source://rack/2.2.4/lib/rack/utils.rb#319
    def rfc2822(time); end

    # source://rack/2.2.4/lib/rack/utils.rb#380
    def secure_compare(a, b); end

    # source://rack/2.2.4/lib/rack/utils.rb#177
    def select_best_encoding(available_encodings, accept_encoding); end

    # source://rack/2.2.4/lib/rack/utils.rb#267
    def set_cookie_header!(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#584
    def status_code(status); end

    # source://rack/2.2.4/lib/rack/utils.rb#56
    def unescape(s, encoding = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#50
    def unescape_path(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#611
    def valid_path?(path); end
  end
end

# source://rack/2.2.4/lib/rack/utils.rb#22
Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

class Rack::Utils::Context
  # source://rack/2.2.4/lib/rack/utils.rb#398
  def initialize(app_f, app_r); end

  # source://rack/2.2.4/lib/rack/utils.rb#396
  def app; end

  # source://rack/2.2.4/lib/rack/utils.rb#403
  def call(env); end

  # source://rack/2.2.4/lib/rack/utils.rb#411
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#396
  def for; end

  # source://rack/2.2.4/lib/rack/utils.rb#407
  def recontext(app); end
end

# source://rack/2.2.4/lib/rack/utils.rb#21
Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#161
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/utils.rb#170
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#511
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Rack::Utils::HeaderHash < ::Hash
  # source://rack/2.2.4/lib/rack/utils.rb#429
  def initialize(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#459
  def [](k); end

  # source://rack/2.2.4/lib/rack/utils.rb#463
  def []=(k, v); end

  # source://rack/2.2.4/lib/rack/utils.rb#442
  def clear; end

  # source://rack/2.2.4/lib/rack/utils.rb#470
  def delete(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#447
  def each; end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def has_key?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def include?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def key?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def member?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#489
  def merge(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#484
  def merge!(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#494
  def replace(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#453
  def to_hash; end

  protected

  # source://rack/2.2.4/lib/rack/utils.rb#501
  def names; end

  private

  # source://rack/2.2.4/lib/rack/utils.rb#436
  def initialize_copy(other); end

  class << self
    # source://rack/2.2.4/lib/rack/utils.rb#421
    def [](headers); end
  end
end

# source://rack/2.2.4/lib/rack/utils.rb#20
Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

# source://rack/2.2.4/lib/rack/utils.rb#23
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

# source://rack/2.2.4/lib/rack/utils.rb#609
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/utils.rb#592
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#19
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# source://rack/2.2.4/lib/rack/utils.rb#25
Rack::Utils::RFC2822_DAY_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/utils.rb#26
Rack::Utils::RFC2822_MONTH_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/utils.rb#578
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/utils.rb#580
Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/version.rb#16
Rack::VERSION = T.let(T.unsafe(nil), Array)

module Rails::Initializable
  mixes_in_class_methods ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/initializable.rb#66
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#58
  def run_initializers(group = T.unsafe(nil), *args); end

  class << self
    # source://railties/7.0.4/lib/rails/initializable.rb#7
    def included(base); end
  end
end

module Rails::Initializable::ClassMethods
  # source://railties/7.0.4/lib/rails/initializable.rb#88
  def initializer(name, opts = T.unsafe(nil), &blk); end

  # source://railties/7.0.4/lib/rails/initializable.rb#71
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#75
  def initializers_chain; end

  # source://railties/7.0.4/lib/rails/initializable.rb#84
  def initializers_for(binding); end
end

class Rails::Initializable::Collection < ::Array
  include ::TSort

  # source://railties/7.0.4/lib/rails/initializable.rb#53
  def +(other); end

  # source://railties/7.0.4/lib/rails/initializable.rb#49
  def tsort_each_child(initializer, &block); end

  def tsort_each_node; end
end

class Rails::Initializable::Initializer
  # source://railties/7.0.4/lib/rails/initializable.rb#14
  def initialize(name, context, options, &block); end

  # source://railties/7.0.4/lib/rails/initializable.rb#23
  def after; end

  # source://railties/7.0.4/lib/rails/initializable.rb#19
  def before; end

  # source://railties/7.0.4/lib/rails/initializable.rb#27
  def belongs_to?(group); end

  # source://railties/7.0.4/lib/rails/initializable.rb#35
  def bind(context); end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def block; end

  # source://railties/7.0.4/lib/rails/initializable.rb#40
  def context_class; end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def name; end

  # source://railties/7.0.4/lib/rails/initializable.rb#31
  def run(*args); end
end

class Rails::Railtie
  include ::Rails::Initializable
  extend ::ActiveSupport::DescendantsTracker
  extend ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/railtie.rb#246
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie.rb#263
  def config; end

  # source://railties/7.0.4/lib/rails/railtie.rb#256
  def configure(&block); end

  # source://railties/7.0.4/lib/rails/railtie.rb#252
  def inspect; end

  # source://railties/7.0.4/lib/rails/railtie.rb#244
  def railtie_name(*_arg0, **_arg1, &_arg2); end

  # source://railties/7.0.4/lib/rails/railtie.rb#267
  def railtie_namespace; end

  protected

  # source://railties/7.0.4/lib/rails/railtie.rb#272
  def run_console_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#276
  def run_generators_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#280
  def run_runner_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#289
  def run_server_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#284
  def run_tasks_blocks(app); end

  private

  # source://railties/7.0.4/lib/rails/railtie.rb#295
  def each_registered_block(type, &block); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie.rb#194
    def <=>(other); end

    # source://railties/7.0.4/lib/rails/railtie.rb#172
    def abstract_railtie?; end

    # source://railties/7.0.4/lib/rails/railtie.rb#146
    def config(*_arg0, **_arg1, &_arg2); end

    # source://railties/7.0.4/lib/rails/railtie.rb#190
    def configure(&block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#156
    def console(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#164
    def generators(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#198
    def inherited(subclass); end

    # source://railties/7.0.4/lib/rails/railtie.rb#183
    def instance; end

    # source://railties/7.0.4/lib/rails/railtie.rb#176
    def railtie_name(name = T.unsafe(nil)); end

    # source://railties/7.0.4/lib/rails/railtie.rb#152
    def rake_tasks(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#160
    def runner(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#168
    def server(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#148
    def subclasses; end

    protected

    # source://railties/7.0.4/lib/rails/railtie.rb#206
    def increment_load_index; end

    # source://railties/7.0.4/lib/rails/railtie.rb#204
    def load_index; end

    private

    # source://railties/7.0.4/lib/rails/railtie.rb#212
    def generate_railtie_name(string); end

    # source://railties/7.0.4/lib/rails/railtie.rb#224
    def method_missing(name, *args, **_arg2, &block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#236
    def register_block_for(type, &blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#216
    def respond_to_missing?(name, _); end
  end
end

# source://railties/7.0.4/lib/rails/railtie.rb#142
Rails::Railtie::ABSTRACT_RAILTIES = T.let(T.unsafe(nil), Array)

class Rails::Railtie::Configuration
  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#8
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#70
  def after_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#47
  def app_generators; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#39
  def app_middleware; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#54
  def before_configuration(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#60
  def before_eager_load(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#65
  def before_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#18
  def eager_load_namespaces; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#85
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#81
  def to_prepare(&blk); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#75
  def to_prepare_blocks; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#30
  def watchable_dirs; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#23
  def watchable_files; end

  private

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#90
  def method_missing(name, *args, &blk); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie/configuration.rb#13
    def eager_load_namespaces; end
  end
end
