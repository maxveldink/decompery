# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `puma` gem.
# Please instead update this file by running `bin/tapioca gem puma`.

module ActiveSupport::DescendantsTracker
  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#88
  def descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#92
  def direct_descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#82
  def subclasses; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#66
    def clear(classes); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#62
    def descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#11
    def direct_descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#50
    def disable_clear!; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#77
    def native?; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#58
    def subclasses(klass); end
  end
end

module Puma
  class << self
    # @return [Boolean]
    #
    # source://puma//lib/puma.rb#42
    def abstract_unix_socket?; end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/detect.rb#39
    def forkable?; end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#21
    def jruby?; end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/detect.rb#34
    def mri?; end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#25
    def osx?; end

    # Thread name is new in Ruby 2.3
    #
    # source://puma//lib/puma.rb#73
    def set_thread_name(name); end

    # @return [Boolean]
    #
    # source://puma//lib/puma.rb#38
    def ssl?; end

    # source://puma//lib/puma.rb#62
    def stats; end

    # @version 5.0.0
    #
    # source://puma//lib/puma.rb#68
    def stats_hash; end

    # source://puma//lib/puma.rb#57
    def stats_object=(val); end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#29
    def windows?; end
  end
end

class Puma::Binder
  include ::Puma::Const

  # @return [Binder] a new instance of Binder
  #
  # source://puma//lib/puma/binder.rb#31
  def initialize(events, conf = T.unsafe(nil)); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def activated_sockets; end

  # source://puma//lib/puma/binder.rb#360
  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on host +host+, port +port+.
  # If +optimize_for_latency+ is true (the default) then clients connecting
  # will be optimized for latency over throughput.
  #
  # +backlog+ indicates how many unaccepted connections the kernel should
  # allow to accumulate before returning connection refused.
  #
  # source://puma//lib/puma/binder.rb#332
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on +path+ as a UNIX domain socket.
  #
  # source://puma//lib/puma/binder.rb#411
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#76
  def close; end

  # source://puma//lib/puma/binder.rb#458
  def close_listeners; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#82
  def connected_ports; end

  # systemd socket activation.
  # LISTEN_FDS = number of listening sockets. e.g. 2 means accept on 2 sockets w/descriptors 3 and 4.
  # LISTEN_PID = PID of the service process, aka us
  #
  # @see https://www.freedesktop.org/software/systemd/man/systemd-socket-activate.html
  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#100
  def create_activated_fds(env_hash); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#87
  def create_inherited_fds(env_hash); end

  # source://puma//lib/puma/binder.rb#72
  def env(sock); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def envs; end

  # source://puma//lib/puma/binder.rb#391
  def inherit_ssl_listener(fd, ctx); end

  # source://puma//lib/puma/binder.rb#353
  def inherit_tcp_listener(host, port, fd); end

  # source://puma//lib/puma/binder.rb#446
  def inherit_unix_listener(path, fd); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def inherited_fds; end

  # Returns the value of attribute ios.
  #
  # source://puma//lib/puma/binder.rb#64
  def ios; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#70
  def ios=(_arg0); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def listeners; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#70
  def listeners=(_arg0); end

  # source://puma//lib/puma/binder.rb#309
  def localhost_authority; end

  # source://puma//lib/puma/binder.rb#313
  def localhost_authority_context; end

  # source://puma//lib/puma/binder.rb#155
  def parse(binds, logger, log_msg = T.unsafe(nil)); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def proto_env; end

  # source://puma//lib/puma/binder.rb#468
  def redirects_for_restart; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#475
  def redirects_for_restart_env; end

  # Synthesize binds from systemd socket activation
  #
  # When systemd socket activation is enabled, it can be tedious to keep the
  # binds in sync. This method can synthesize any binds based on the received
  # activated sockets. Any existing matching binds will be respected.
  #
  # When only_matching is true in, all binds that do not match an activated
  # socket is removed in place.
  #
  # It's a noop if no activated sockets were received.
  #
  # source://puma//lib/puma/binder.rb#128
  def synthesize_binds_from_activated_fs(binds, only_matching); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#67
  def unix_paths; end

  private

  # source://puma//lib/puma/binder.rb#490
  def loc_addr_str(io); end

  # source://puma//lib/puma/binder.rb#484
  def loopback_addresses; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#500
  def socket_activation_fd(int); end
end

# source://puma//lib/puma/binder.rb#29
Puma::Binder::RACK_VERSION = T.let(T.unsafe(nil), Array)

# An instance of this class represents a unique request from a client.
# For example, this could be a web request from a browser or from CURL.
#
# An instance of `Puma::Client` can be used as if it were an IO object
# by the reactor. The reactor is expected to call `#to_io`
# on any non-IO objects it polls. For example, nio4r internally calls
# `IO::try_convert` (which may call `#to_io`) when a new socket is
# registered.
#
# Instances of this class are responsible for knowing if
# the header and body are fully buffered via the `try_to_finish` method.
# They can be used to "time out" a response via the `timeout_at` reader.
class Puma::Client
  include ::Puma::Const
  extend ::Forwardable

  # @return [Client] a new instance of Client
  #
  # source://puma//lib/puma/client.rb#62
  def initialize(io, env = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://puma//lib/puma/client.rb#98
  def body; end

  # For the hijack protocol (allows us to just put the Client object
  # into the env)
  #
  # source://puma//lib/puma/client.rb#120
  def call; end

  # Returns true if the persistent connection can be closed immediately
  # without waiting for the configured idle/shutdown timeout.
  #
  # @return [Boolean]
  # @version 5.0.0
  #
  # source://puma//lib/puma/client.rb#288
  def can_close?; end

  # source://puma//lib/puma/client.rb#177
  def close; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def closed?(*args, **_arg1, &block); end

  # source://puma//lib/puma/client.rb#249
  def eagerly_finish; end

  # Returns the value of attribute env.
  #
  # source://puma//lib/puma/client.rb#98
  def env; end

  # source://puma//lib/puma/client.rb#293
  def expect_proxy_proto=(val); end

  # source://puma//lib/puma/client.rb#255
  def finish(timeout); end

  # Returns the value of attribute hijacked.
  #
  # source://puma//lib/puma/client.rb#98
  def hijacked; end

  # source://puma//lib/puma/client.rb#126
  def in_data_phase; end

  # source://puma//lib/puma/client.rb#114
  def inspect; end

  # Returns the value of attribute io.
  #
  # source://puma//lib/puma/client.rb#98
  def io; end

  # Test to see if io meets a bare minimum of functioning, @to_io needs to be
  # used for MiniSSL::Socket
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/client.rb#109
  def io_ok?; end

  # Returns the value of attribute listener.
  #
  # source://puma//lib/puma/client.rb#103
  def listener; end

  # Sets the attribute listener
  #
  # @param value the value to set the attribute listener to.
  #
  # source://puma//lib/puma/client.rb#103
  def listener=(_arg0); end

  # source://puma//lib/puma/client.rb#272
  def peerip; end

  # Sets the attribute peerip
  #
  # @param value the value to set the attribute peerip to.
  #
  # source://puma//lib/puma/client.rb#101
  def peerip=(_arg0); end

  # Returns the value of attribute ready.
  #
  # source://puma//lib/puma/client.rb#98
  def ready; end

  # Returns the value of attribute remote_addr_header.
  #
  # source://puma//lib/puma/client.rb#103
  def remote_addr_header; end

  # Sets the attribute remote_addr_header
  #
  # @param value the value to set the attribute remote_addr_header to.
  #
  # source://puma//lib/puma/client.rb#103
  def remote_addr_header=(_arg0); end

  # source://puma//lib/puma/client.rb#139
  def reset(fast_check = T.unsafe(nil)); end

  # source://puma//lib/puma/client.rb#130
  def set_timeout(val); end

  # Returns the value of attribute tempfile.
  #
  # source://puma//lib/puma/client.rb#98
  def tempfile; end

  # Number of seconds until the timeout elapses.
  #
  # source://puma//lib/puma/client.rb#135
  def timeout; end

  # @raise [ConnectionError]
  #
  # source://puma//lib/puma/client.rb#260
  def timeout!; end

  # Returns the value of attribute timeout_at.
  #
  # source://puma//lib/puma/client.rb#98
  def timeout_at; end

  # Returns the value of attribute to_io.
  #
  # source://puma//lib/puma/client.rb#98
  def to_io; end

  # source://puma//lib/puma/client.rb#209
  def try_to_finish; end

  # If necessary, read the PROXY protocol from the buffer. Returns
  # false if more data is needed.
  #
  # source://puma//lib/puma/client.rb#187
  def try_to_parse_proxy_protocol; end

  # source://puma//lib/puma/client.rb#265
  def write_error(status_code); end

  private

  # source://puma//lib/puma/client.rb#480
  def decode_chunk(chunk); end

  # source://puma//lib/puma/client.rb#388
  def read_body; end

  # source://puma//lib/puma/client.rb#433
  def read_chunked_body; end

  # source://puma//lib/puma/client.rb#577
  def set_ready; end

  # source://puma//lib/puma/client.rb#306
  def setup_body; end

  # source://puma//lib/puma/client.rb#458
  def setup_chunked_body(body); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/client.rb#476
  def write_chunk(str); end
end

# this tests all values but the last, which must be chunked
#
# source://puma//lib/puma/client.rb#44
Puma::Client::ALLOWED_TRANSFER_ENCODING = T.let(T.unsafe(nil), Array)

# chunked body validation
#
# source://puma//lib/puma/client.rb#47
Puma::Client::CHUNK_SIZE_INVALID = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#48
Puma::Client::CHUNK_VALID_ENDING = T.let(T.unsafe(nil), String)

# Content-Length header value validation
#
# source://puma//lib/puma/client.rb#51
Puma::Client::CONTENT_LENGTH_VALUE_INVALID = T.let(T.unsafe(nil), Regexp)

# The object used for a request with no body. All requests with
# no body share this one object since it has no state.
#
# source://puma//lib/puma/client.rb#57
Puma::Client::EmptyBody = T.let(T.unsafe(nil), Puma::NullIO)

# source://puma//lib/puma/client.rb#53
Puma::Client::TE_ERR_MSG = T.let(T.unsafe(nil), String)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when puma "workers" are needed
# i.e. when using multi-processes. For example `$ puma -w 5`
#
# An instance of this class will spawn the number of processes passed in
# via the `spawn_workers` method call. Each worker will have it's own
# instance of a `Puma::Server`.
class Puma::Cluster < ::Puma::Runner
  # @return [Cluster] a new instance of Cluster
  #
  # source://puma//lib/puma/cluster.rb#20
  def initialize(cli, events); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#149
  def all_workers_booted?; end

  # source://puma//lib/puma/cluster.rb#153
  def check_workers; end

  # source://puma//lib/puma/cluster.rb#132
  def cull_start_index(diff); end

  # source://puma//lib/puma/cluster.rb#108
  def cull_workers; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#276
  def fork_worker!; end

  # source://puma//lib/puma/cluster.rb#233
  def halt; end

  # source://puma//lib/puma/cluster.rb#142
  def next_worker_index; end

  # source://puma//lib/puma/cluster.rb#212
  def phased_restart; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#271
  def preload?; end

  # source://puma//lib/puma/cluster.rb#57
  def redirect_io; end

  # source://puma//lib/puma/cluster.rb#238
  def reload_worker_directory; end

  # source://puma//lib/puma/cluster.rb#207
  def restart; end

  # source://puma//lib/puma/cluster.rb#336
  def run; end

  # We do this in a separate method to keep the lambda scope
  # of the signals handlers as small as possible.
  #
  # source://puma//lib/puma/cluster.rb#285
  def setup_signals; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#94
  def spawn_worker(idx, master); end

  # source://puma//lib/puma/cluster.rb#63
  def spawn_workers; end

  # source://puma//lib/puma/cluster.rb#45
  def start_phased_restart; end

  # Inside of a child process, this will return all zeroes, as @workers is only populated in
  # the master process.
  #
  # source://puma//lib/puma/cluster.rb#247
  def stats; end

  # source://puma//lib/puma/cluster.rb#221
  def stop; end

  # source://puma//lib/puma/cluster.rb#226
  def stop_blocked; end

  # source://puma//lib/puma/cluster.rb#30
  def stop_workers; end

  # source://puma//lib/puma/cluster.rb#185
  def worker(index, master); end

  # source://puma//lib/puma/cluster.rb#122
  def workers_to_cull(diff); end

  private

  # source://puma//lib/puma/cluster.rb#497
  def single_worker_warning; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#532
  def timeout_workers; end

  # loops thru @workers, removing workers that exited, and calling
  # `#term` if needed
  #
  # source://puma//lib/puma/cluster.rb#508
  def wait_workers; end
end

# This class is instantiated by the `Puma::Cluster` and represents a single
# worker process.
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
class Puma::Cluster::Worker < ::Puma::Runner
  # @return [Worker] a new instance of Worker
  #
  # source://puma//lib/puma/cluster/worker.rb#14
  def initialize(index:, master:, launcher:, pipes:, server: T.unsafe(nil)); end

  # Returns the value of attribute index.
  #
  # source://puma//lib/puma/cluster/worker.rb#12
  def index; end

  # Returns the value of attribute master.
  #
  # source://puma//lib/puma/cluster/worker.rb#12
  def master; end

  # source://puma//lib/puma/cluster/worker.rb#28
  def run; end

  private

  # source://puma//lib/puma/cluster/worker.rb#149
  def spawn_worker(idx); end
end

# This class represents a worker process from the perspective of the puma
# master process. It contains information about the process and its health
# and it exposes methods to control the process via IPC. It does not
# include the actual logic executed by the worker process itself. For that,
# see Puma::Cluster::Worker.
class Puma::Cluster::WorkerHandle
  # @return [WorkerHandle] a new instance of WorkerHandle
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#11
  def initialize(idx, pid, phase, options); end

  # source://puma//lib/puma/cluster/worker_handle.rb#38
  def boot!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#30
  def booted?; end

  # source://puma//lib/puma/cluster/worker_handle.rb#88
  def hup; end

  # Returns the value of attribute index.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def index; end

  # source://puma//lib/puma/cluster/worker_handle.rb#83
  def kill; end

  # Returns the value of attribute last_checkin.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def last_checkin; end

  # Returns the value of attribute last_status.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def last_status; end

  # Returns the value of attribute phase.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def phase; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#28
  def phase=(_arg0); end

  # Returns the value of attribute pid.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def pid; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#28
  def pid=(_arg0); end

  # source://puma//lib/puma/cluster/worker_handle.rb#51
  def ping!(status); end

  # @see Puma::Cluster#check_workers
  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#62
  def ping_timeout; end

  # Returns the value of attribute signal.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def signal; end

  # Returns the value of attribute started_at.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#25
  def started_at; end

  # source://puma//lib/puma/cluster/worker_handle.rb#70
  def term; end

  # source://puma//lib/puma/cluster/worker_handle.rb#43
  def term!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#47
  def term?; end

  # source://puma//lib/puma/cluster/worker_handle.rb#34
  def uptime; end
end

module Puma::ConfigDefault; end

# source://puma//lib/puma/configuration.rb#10
Puma::ConfigDefault::DefaultRackup = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/configuration.rb#12
Puma::ConfigDefault::DefaultTCPHost = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/configuration.rb#13
Puma::ConfigDefault::DefaultTCPPort = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/configuration.rb#14
Puma::ConfigDefault::DefaultWorkerCheckInterval = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/configuration.rb#16
Puma::ConfigDefault::DefaultWorkerShutdownTimeout = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/configuration.rb#15
Puma::ConfigDefault::DefaultWorkerTimeout = T.let(T.unsafe(nil), Integer)

# The main configuration class of Puma.
#
# It can be initialized with a set of "user" options and "default" options.
# Defaults will be merged with `Configuration.puma_default_options`.
#
# This class works together with 2 main other classes the `UserFileDefaultOptions`
# which stores configuration options in order so the precedence is that user
# set configuration wins over "file" based configuration wins over "default"
# configuration. These configurations are set via the `DSL` class. This
# class powers the Puma config file syntax and does double duty as a configuration
# DSL used by the `Puma::CLI` and Puma rack handler.
#
# It also handles loading plugins.
#
# [Note:]
#   `:port` and `:host` are not valid keys. By the time they make it to the
#   configuration options they are expected to be incorporated into a `:binds` key.
#   Under the hood the DSL maps `port` and `host` calls to `:binds`
#
#     config = Configuration.new({}) do |user_config, file_config, default_config|
#       user_config.port 3003
#     end
#     config.load
#     puts config.options[:port]
#     # => 3003
#
# It is expected that `load` is called on the configuration instance after setting
# config. This method expands any values in `config_file` and puts them into the
# correct configuration option hash.
#
# Once all configuration is complete it is expected that `clamp` will be called
# on the instance. This will expand any procs stored under "default" values. This
# is done because an environment variable may have been modified while loading
# configuration files.
class Puma::Configuration
  include ::Puma::ConfigDefault

  # @return [Configuration] a new instance of Configuration
  #
  # source://puma//lib/puma/configuration.rb#141
  def initialize(user_options = T.unsafe(nil), default_options = T.unsafe(nil), &block); end

  # Load the specified rackup file, pull options from
  # the rackup file, and set @app.
  #
  # source://puma//lib/puma/configuration.rb#269
  def app; end

  # Indicate if there is a properly configured app
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/configuration.rb#258
  def app_configured?; end

  # Call once all configuration (included from rackup files)
  # is loaded to flesh out any defaults
  #
  # source://puma//lib/puma/configuration.rb#239
  def clamp; end

  # source://puma//lib/puma/configuration.rb#224
  def config_files; end

  # source://puma//lib/puma/configuration.rb#161
  def configure; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/configuration.rb#185
  def default_max_threads; end

  # Return which environment we're running in
  #
  # source://puma//lib/puma/configuration.rb#282
  def environment; end

  # source://puma//lib/puma/configuration.rb#286
  def environment_str; end

  # source://puma//lib/puma/configuration.rb#305
  def final_options; end

  # source://puma//lib/puma/configuration.rb#175
  def flatten; end

  # source://puma//lib/puma/configuration.rb#179
  def flatten!; end

  # source://puma//lib/puma/configuration.rb#218
  def load; end

  # source://puma//lib/puma/configuration.rb#290
  def load_plugin(name); end

  # Returns the value of attribute options.
  #
  # source://puma//lib/puma/configuration.rb#159
  def options; end

  # Returns the value of attribute plugins.
  #
  # source://puma//lib/puma/configuration.rb#159
  def plugins; end

  # source://puma//lib/puma/configuration.rb#189
  def puma_default_options; end

  # source://puma//lib/puma/configuration.rb#262
  def rackup; end

  # source://puma//lib/puma/configuration.rb#294
  def run_hooks(key, arg, events); end

  private

  # source://puma//lib/puma/configuration.rb#318
  def infer_tag; end

  # source://puma//lib/puma/configuration.rb#169
  def initialize_copy(other); end

  # source://puma//lib/puma/configuration.rb#345
  def load_rackup; end

  # Load and use the normal Rack builder if we can, otherwise
  # fallback to our minimal version.
  #
  # source://puma//lib/puma/configuration.rb#324
  def rack_builder; end

  class << self
    # source://puma//lib/puma/configuration.rb#363
    def random_token; end

    # source://puma//lib/puma/configuration.rb#309
    def temp_path; end
  end
end

# Injects the Configuration object into the env
class Puma::Configuration::ConfigMiddleware
  # @return [ConfigMiddleware] a new instance of ConfigMiddleware
  #
  # source://puma//lib/puma/configuration.rb#245
  def initialize(config, app); end

  # source://puma//lib/puma/configuration.rb#250
  def call(env); end
end

class Puma::ConnectionError < ::RuntimeError; end

# Frequently used constants when constructing requests or responses.  Many times
# the constant just refers to a string with the same contents.  Using these constants
# gave about a 3% to 10% performance improvement over using the strings directly.
#
# The constants are frozen because Hash#[]= when called with a String key dups
# the String UNLESS the String is frozen. This saves us therefore 2 object
# allocations when creating the env hash later.
#
# While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,
# REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or
# too taxing on performance.
module Puma::Const; end

# Banned keys of response header
#
# source://puma//lib/puma/const.rb#248
Puma::Const::BANNED_HEADER_KEY = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#187
Puma::Const::CGI_VER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#228
Puma::Const::CHUNKED = T.let(T.unsafe(nil), String)

# The basic max request size we'll try to read.
#
# source://puma//lib/puma/const.rb#155
Puma::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#214
Puma::Const::CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#226
Puma::Const::CLOSE_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#104
Puma::Const::CODE_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#230
Puma::Const::COLON = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#222
Puma::Const::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#223
Puma::Const::CONNECTION_KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#133
Puma::Const::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#217
Puma::Const::CONTENT_LENGTH2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#218
Puma::Const::CONTENT_LENGTH_S = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#208
Puma::Const::CONTINUE = T.let(T.unsafe(nil), String)

# Illegal character in the key or value of response header
#
# source://puma//lib/puma/const.rb#241
Puma::Const::DQUOTE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#238
Puma::Const::EARLY_HINTS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#139
Puma::Const::ERROR_RESPONSE = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/const.rb#108
Puma::Const::FAST_TRACK_KA_TIMEOUT = T.let(T.unsafe(nil), Float)

# The default number of seconds to wait until we get the first data
# for the request
#
# source://puma//lib/puma/const.rb#116
Puma::Const::FIRST_DATA_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#186
Puma::Const::GATEWAY_INTERFACE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#190
Puma::Const::HALT_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#165
Puma::Const::HEAD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#235
Puma::Const::HIJACK = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#236
Puma::Const::HIJACK_IO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#234
Puma::Const::HIJACK_P = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#200
Puma::Const::HTTP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#201
Puma::Const::HTTPS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#203
Puma::Const::HTTPS_KEY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#212
Puma::Const::HTTP_10_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#183
Puma::Const::HTTP_11 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#210
Puma::Const::HTTP_11_100 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#211
Puma::Const::HTTP_11_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#206
Puma::Const::HTTP_CONNECTION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#207
Puma::Const::HTTP_EXPECT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#242
Puma::Const::HTTP_HEADER_DELIMITER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#176
Puma::Const::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#205
Puma::Const::HTTP_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#169
Puma::Const::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#172
Puma::Const::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#171
Puma::Const::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#170
Puma::Const::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#243
Puma::Const::ILLEGAL_HEADER_KEY_REGEX = T.let(T.unsafe(nil), Regexp)

# header values can contain HTAB?
#
# source://puma//lib/puma/const.rb#245
Puma::Const::ILLEGAL_HEADER_VALUE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#215
Puma::Const::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)
#
# source://puma//lib/puma/const.rb#167
Puma::Const::LINE_END = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#179
Puma::Const::LOCALHOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#180
Puma::Const::LOCALHOST_IP = T.let(T.unsafe(nil), String)

# Maximum request body size before it is moved out of memory and into a tempfile for reading.
#
# source://puma//lib/puma/const.rb#162
Puma::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# How many requests to attempt inline before sending a client back to
# the reactor to be subject to normal ordering. The idea here is that
# we amortize the cost of going back to the reactor for a well behaved
# but very "greedy" client across 10 requests. This prevents a not
# well behaved client from monopolizing the thread forever.
#
# source://puma//lib/puma/const.rb#127
Puma::Const::MAX_FAST_INLINE = T.let(T.unsafe(nil), Integer)

# This is the maximum header that is allowed before a client is booted.  The parser detects
# this, but we'd also like to do this as well.
#
# source://puma//lib/puma/const.rb#159
Puma::Const::MAX_HEADER = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#232
Puma::Const::NEWLINE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#135
Puma::Const::PATH_INFO = T.let(T.unsafe(nil), String)

# The default number of seconds for another request within a persistent
# session.
#
# source://puma//lib/puma/const.rb#112
Puma::Const::PERSISTENT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#178
Puma::Const::PORT_443 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#177
Puma::Const::PORT_80 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#250
Puma::Const::PROXY_PROTOCOL_V1_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#197
Puma::Const::PUMA_CONFIG = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#198
Puma::Const::PUMA_PEERCERT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#106
Puma::Const::PUMA_SERVER_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#196
Puma::Const::PUMA_SOCKET = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#137
Puma::Const::PUMA_TMP_BASE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::PUMA_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#132
Puma::Const::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#195
Puma::Const::RACK_AFTER_REPLY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#193
Puma::Const::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#194
Puma::Const::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#168
Puma::Const::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#164
Puma::Const::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#131
Puma::Const::REQUEST_PATH = T.let(T.unsafe(nil), String)

# The original URI requested by the client.
#
# source://puma//lib/puma/const.rb#130
Puma::Const::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#191
Puma::Const::RESTART_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#174
Puma::Const::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#175
Puma::Const::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#182
Puma::Const::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#185
Puma::Const::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#189
Puma::Const::STOP_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#219
Puma::Const::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#220
Puma::Const::TRANSFER_ENCODING2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#225
Puma::Const::TRANSFER_ENCODING_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::VERSION = T.let(T.unsafe(nil), String)

# How long to wait when getting some write blocking on the socket when
# sending data back
#
# source://puma//lib/puma/const.rb#120
Puma::Const::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The methods that are available for use inside the configuration file.
# These same methods are used in Puma cli and the rack handler
# internally.
#
# Used manually (via CLI class):
#
#   config = Configuration.new({}) do |user_config|
#     user_config.port 3001
#   end
#   config.load
#
#   puts config.options[:binds] # => "tcp://127.0.0.1:3001"
#
# Used to load file:
#
#   $ cat puma_config.rb
#   port 3002
#
# Resulting configuration:
#
#   config = Configuration.new(config_file: "puma_config.rb")
#   config.load
#
#   puts config.options[:binds] # => "tcp://127.0.0.1:3002"
#
# You can also find many examples being used by the test suite in
# +test/config+.
class Puma::DSL
  include ::Puma::ConfigDefault

  # @return [DSL] a new instance of DSL
  #
  # source://puma//lib/puma/dsl.rb#77
  def initialize(options, config); end

  # source://puma//lib/puma/dsl.rb#84
  def _load_from(path); end

  # source://puma//lib/puma/dsl.rb#93
  def _offer_plugins; end

  # Start the Puma control rack application on +url+. This application can
  # be communicated with to control the main server. Additionally, you can
  # provide an authentication token, so all requests to the control server
  # will need to include that token as a query parameter. This allows for
  # simple authentication.
  #
  # Check out {Puma::App::Status} to see what the app has available.
  #
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock'
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock', { auth_token: '12345' }
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock', { no_token: true }
  #
  # source://puma//lib/puma/dsl.rb#167
  def activate_control_app(url = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Code to run in the master after a worker has been started. The worker's
  # index is passed as an argument.
  #
  # This is called everytime a worker is to be started.
  #
  # @example
  #   after_worker_fork do
  #   puts 'After worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#610
  def after_worker_boot(&block); end

  # Code to run in the master after a worker has been started. The worker's
  # index is passed as an argument.
  #
  # This is called everytime a worker is to be started.
  #
  # @example
  #   after_worker_fork do
  #   puts 'After worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#610
  def after_worker_fork(&block); end

  # Use an object or block as the rack application. This allows the
  # configuration file to be the application itself.
  #
  # @example
  #   app do |env|
  #   body = 'Hello, World!'
  #
  #   [
  #   200,
  #   {
  #   'Content-Type' => 'text/plain',
  #   'Content-Length' => body.length.to_s
  #   },
  #   [body]
  #   ]
  #   end
  # @see Puma::Configuration#app
  #
  # source://puma//lib/puma/dsl.rb#145
  def app(obj = T.unsafe(nil), &block); end

  # Code to run immediately before master process
  # forks workers (once on boot). These hooks can block if necessary
  # to wait for background operations unknown to Puma to finish before
  # the process terminates.
  # This can be used to close any connections to remote servers (database,
  # Redis, ...) that were opened when preloading the code.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_fork do
  #   puts "Starting workers..."
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#548
  def before_fork(&block); end

  # Bind the server to +url+. "tcp://", "unix://" and "ssl://" are the only
  # accepted protocols. Multiple urls can be bound to, calling +bind+ does
  # not overwrite previous bindings.
  #
  # The default is "tcp://0.0.0.0:9292".
  #
  # You can use query parameters within the url to specify options:
  #
  # * Set the socket backlog depth with +backlog+, default is 1024.
  # * Set up an SSL certificate with +key+ & +cert+.
  # * Set whether to optimize for low latency instead of throughput with
  #   +low_latency+, default is to not optimize for low latency. This is done
  #   via +Socket::TCP_NODELAY+.
  # * Set socket permissions with +umask+.
  #
  # @example Backlog depth
  #   bind 'unix:///var/run/puma.sock?backlog=512'
  # @example SSL cert
  #   bind 'ssl://127.0.0.1:9292?key=key.key&cert=cert.pem'
  # @example Disable optimization for low latency
  #   bind 'tcp://0.0.0.0:9292?low_latency=false'
  # @example Socket permissions
  #   bind 'unix:///var/run/puma.sock?umask=0111'
  # @see Puma::Runner#load_and_bind
  # @see Puma::Cluster#run
  #
  # source://puma//lib/puma/dsl.rb#225
  def bind(url); end

  # Bind to (systemd) activated sockets, regardless of configured binds.
  #
  # Systemd can present sockets as file descriptors that are already opened.
  # By default Puma will use these but only if it was explicitly told to bind
  # to the socket. If not, it will close the activated sockets. This means
  # all configuration is duplicated.
  #
  # Binds can contain additional configuration, but only SSL config is really
  # relevant since the unix and TCP socket options are ignored.
  #
  # This means there is a lot of duplicated configuration for no additional
  # value in most setups. This method tells the launcher to bind to all
  # activated sockets, regardless of existing bind.
  #
  # To clear configured binds, the value only can be passed. This will clear
  # out any binds that may have been configured.
  #
  # @example Use any systemd activated sockets as well as configured binds
  #   bind_to_activated_sockets
  # @example Only bind to systemd activated sockets, ignoring other binds
  #   bind_to_activated_sockets 'only'
  #
  # source://puma//lib/puma/dsl.rb#256
  def bind_to_activated_sockets(bind = T.unsafe(nil)); end

  # Work around leaky apps that leave garbage in Thread locals
  # across requests.
  #
  # source://puma//lib/puma/dsl.rb#283
  def clean_thread_locals(which = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#230
  def clear_binds!; end

  # Show debugging info
  #
  # source://puma//lib/puma/dsl.rb#376
  def debug; end

  # source://puma//lib/puma/dsl.rb#108
  def default_host; end

  # The directory to operate out of.
  #
  # The default is the current directory.
  #
  # @example
  #   directory '/u/apps/lolcat'
  #
  # source://puma//lib/puma/dsl.rb#660
  def directory(dir); end

  # When shutting down, drain the accept socket of pending connections and
  # process them. This loops over the accept socket until there are no more
  # read events and then stops looking and waits for the requests to finish.
  #
  # @see Puma::Server#graceful_shutdown
  #
  # source://puma//lib/puma/dsl.rb#292
  def drain_on_shutdown(which = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#397
  def early_hints(answer = T.unsafe(nil)); end

  # Set the environment in which the rack's app will run. The value must be
  # a string.
  #
  # The default is "development".
  #
  # @example
  #   environment 'production'
  #
  # source://puma//lib/puma/dsl.rb#303
  def environment(environment); end

  # When using prune_bundler, if extra runtime dependencies need to be loaded to
  # initialize your app, then this setting can be used. This includes any Puma plugins.
  #
  # Before bundler is pruned, the gem names supplied will be looked up in the bundler
  # context and then loaded again after bundler is pruned.
  # Only applies if prune_bundler is used.
  #
  # @example
  #   extra_runtime_dependencies ['gem_name_1', 'gem_name_2']
  # @example
  #   extra_runtime_dependencies ['puma_worker_killer', 'puma-heroku']
  # @see Puma::Launcher#extra_runtime_deps_directories
  #
  # source://puma//lib/puma/dsl.rb#737
  def extra_runtime_dependencies(answer = T.unsafe(nil)); end

  # Define how long the tcp socket stays open, if no data has been received.
  #
  # @see Puma::Server.new
  #
  # source://puma//lib/puma/dsl.rb#277
  def first_data_timeout(seconds); end

  # How long to wait for threads to stop when shutting them
  # down. Defaults to :forever. Specifying :immediately will cause
  # Puma to kill the threads immediately.  Otherwise the value
  # is the number of seconds to wait.
  #
  # Puma always waits a few seconds after killing a thread for it to try
  # to finish up it's work, even in :immediately mode.
  #
  # @see Puma::Server#graceful_shutdown
  #
  # source://puma//lib/puma/dsl.rb#315
  def force_shutdown_after(val = T.unsafe(nil)); end

  # When enabled, workers will be forked from worker 0 instead of from the master process.
  # This option is similar to `preload_app` because the app is preloaded before forking,
  # but it is compatible with phased restart.
  #
  # This option also enables the `refork` command (SIGURG), which optimizes copy-on-write performance
  # in a running app.
  #
  # A refork will automatically trigger once after the specified number of requests
  # (default 1000), or pass 0 to disable auto refork.
  #
  # @note Cluster mode only.
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#941
  def fork_worker(after_requests = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#116
  def get(key, default = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#112
  def inject(&blk); end

  # Specify the backend for the IO selector.
  #
  # Provided values will be passed directly to +NIO::Selector.new+, with the
  # exception of +:auto+ which will let nio4r choose the backend.
  #
  # Check the documentation of +NIO::Selector.backends+ for the list of valid
  # options. Note that the available options on your system will depend on the
  # operating system. If you want to use the pure Ruby backend (not
  # recommended due to its comparatively low performance), set environment
  # variable +NIO4R_PURE+ to +true+.
  #
  # The default is +:auto+.
  #
  # @see https://github.com/socketry/nio4r/blob/master/lib/nio/selector.rb
  #
  # source://puma//lib/puma/dsl.rb#984
  def io_selector_backend(backend); end

  # Load additional configuration from a file
  # Files get loaded later via Configuration#load
  #
  # source://puma//lib/puma/dsl.rb#194
  def load(file); end

  # source://puma//lib/puma/dsl.rb#414
  def log_formatter(&block); end

  # Enable request logging
  #
  # source://puma//lib/puma/dsl.rb#370
  def log_requests(which = T.unsafe(nil)); end

  # Use +obj+ or +block+ as the low level error handler. This allows the
  # configuration file to change the default error on the server.
  #
  # @example
  #   lowlevel_error_handler do |err|
  #   [200, {}, ["error page"]]
  #   end
  #
  # source://puma//lib/puma/dsl.rb#681
  def lowlevel_error_handler(obj = T.unsafe(nil), &block); end

  # The number of requests to attempt inline before sending a client back to
  # the reactor to be subject to normal ordering.
  #
  # source://puma//lib/puma/dsl.rb#965
  def max_fast_inline(num_of_requests); end

  # source://puma//lib/puma/dsl.rb#988
  def mutate_stdout_and_stderr_to_sync_on_write(enabled = T.unsafe(nil)); end

  # When enabled, Puma will GC 4 times before forking workers.
  # If available (Ruby 2.7+), we will also call GC.compact.
  # Not recommended for non-MRI Rubies.
  #
  # Based on the work of Koichi Sasada and Aaron Patterson, this option may
  # decrease memory utilization of preload-enabled cluster-mode Pumas. It will
  # also increase time to boot and fork. See your logs for details on how much
  # time this adds to your boot process. For most apps, it will be less than one
  # second.
  #
  # @see Puma::Cluster#nakayoshi_gc
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#958
  def nakayoshi_fork(enabled = T.unsafe(nil)); end

  # When `fork_worker` is enabled, code to run in Worker 0
  # before all other workers are re-forked from this process,
  # after the server has temporarily stopped serving requests
  # (once per complete refork cycle).
  #
  # This can be used to trigger extra garbage-collection to maximize
  # copy-on-write efficiency, or close any connections to remote servers
  # (database, Redis, ...) that were opened while the server was running.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   on_refork do
  #   3.times {GC.start}
  #   end
  # @note Cluster mode with `fork_worker` enabled only.
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#635
  def on_refork(&block); end

  # Code to run before doing a restart. This code should
  # close log files, database connections, etc.
  #
  # This can be called multiple times to add code each time.
  #
  # @example
  #   on_restart do
  #   puts 'On restart...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#337
  def on_restart(&block); end

  # Code to run in a worker when it boots to setup
  # the process before booting the app.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   on_worker_boot do
  #   puts 'Before worker boot...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#563
  def on_worker_boot(&block); end

  # Code to run in the master right before a worker is started. The worker's
  # index is passed as an argument.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   on_worker_fork do
  #   puts 'Before worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#595
  def on_worker_fork(&block); end

  # Code to run immediately before a worker shuts
  # down (after it has finished processing HTTP requests). These hooks
  # can block if necessary to wait for background operations unknown
  # to Puma to finish before the process terminates.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   on_worker_shutdown do
  #   puts 'On worker shutdown...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#580
  def on_worker_shutdown(&block); end

  # Code to run out-of-band when the worker is idle.
  # These hooks run immediately after a request has finished
  # processing and there are no busy threads on the worker.
  # The worker doesn't accept new requests until this code finishes.
  #
  # This hook is useful for running out-of-band garbage collection
  # or scheduling asynchronous tasks to execute after a response.
  #
  # This can be called multiple times to add several hooks.
  #
  # source://puma//lib/puma/dsl.rb#649
  def out_of_band(&block); end

  # Define how long persistent connections can be idle before Puma closes them.
  #
  # @see Puma::Server.new
  #
  # source://puma//lib/puma/dsl.rb#271
  def persistent_timeout(seconds); end

  # Store the pid of the server in the file at "path".
  #
  # @example
  #   pidfile '/u/apps/lolcat/tmp/pids/puma.pid'
  #
  # source://puma//lib/puma/dsl.rb#356
  def pidfile(path); end

  # Load the named plugin for use by this configuration
  #
  # source://puma//lib/puma/dsl.rb#122
  def plugin(name); end

  # Define the TCP port to bind to. Use +bind+ for more advanced options.
  #
  # @example
  #   port 9292
  #
  # source://puma//lib/puma/dsl.rb#264
  def port(port, host = T.unsafe(nil)); end

  # Preload the application before starting the workers; this conflicts with
  # phased restart feature. On by default if your app uses more than 1 worker.
  #
  # @example
  #   preload_app!
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#670
  def preload_app!(answer = T.unsafe(nil)); end

  # This option is used to allow your app and its gems to be
  # properly reloaded when not using preload.
  #
  # When set, if Puma detects that it's been invoked in the
  # context of Bundler, it will cleanup the environment and
  # re-run itself outside the Bundler environment, but directly
  # using the files that Bundler has setup.
  #
  # This means that Puma is now decoupled from your Bundler
  # context and when each worker loads, it will be loading a
  # new Bundler context and thus can float around as the release
  # dictates.
  #
  # @note This is incompatible with +preload_app!+.
  # @note This is only supported for RubyGems 2.2+
  # @see extra_runtime_dependencies
  #
  # source://puma//lib/puma/dsl.rb#704
  def prune_bundler(answer = T.unsafe(nil)); end

  # When set to true (the default), workers accept all requests
  # and queue them before passing them to the handlers.
  # When set to false, each worker process accepts exactly as
  # many requests as it is configured to simultaneously handle.
  #
  # Queueing requests generally improves performance. In some
  # cases, such as a single threaded application, it may be
  # better to ensure requests get balanced across workers.
  #
  # Note that setting this to false disables HTTP keepalive and
  # slow clients will occupy a handler thread while the request
  # is being sent. A reverse proxy, such as nginx, can handle
  # slow clients and queue requests before they reach Puma.
  #
  # @see Puma::Server
  #
  # source://puma//lib/puma/dsl.rb#851
  def queue_requests(answer = T.unsafe(nil)); end

  # Disable request logging, if this isn't used it'll be enabled by default.
  #
  # @example
  #   quiet
  #
  # source://puma//lib/puma/dsl.rb#364
  def quiet(which = T.unsafe(nil)); end

  # Allows setting `env['rack.url_scheme']`.
  # Only necessary if X-Forwarded-Proto is not being set by your proxy
  # Normal values are 'http' or 'https'.
  #
  # source://puma//lib/puma/dsl.rb#393
  def rack_url_scheme(scheme = T.unsafe(nil)); end

  # Load +path+ as a rackup file.
  #
  # The default is "config.ru".
  #
  # @example
  #   rackup '/u/apps/lolcat/config.ru'
  #
  # source://puma//lib/puma/dsl.rb#386
  def rackup(path); end

  # By default, Puma will raise SignalException when SIGTERM is received. In
  # environments where SIGTERM is something expected, you can suppress these
  # with this option.
  #
  # This can be useful for example in Kubernetes, where rolling restart is
  # guaranteed usually on infrastructure level.
  #
  # @example
  #   raise_exception_on_sigterm false
  # @see Puma::Launcher#setup_signals
  # @see Puma::Cluster#setup_signals
  #
  # source://puma//lib/puma/dsl.rb#720
  def raise_exception_on_sigterm(answer = T.unsafe(nil)); end

  # Command to use to restart Puma. This should be just how to
  # load Puma itself (ie. 'ruby -Ilib bin/puma'), not the arguments
  # to Puma, as those are the same as the original process.
  #
  # @example
  #   restart_command '/u/app/lolcat/bin/restart_puma'
  #
  # source://puma//lib/puma/dsl.rb#348
  def restart_command(cmd); end

  # source://puma//lib/puma/dsl.rb#104
  def set_default_host(host); end

  # Control how the remote address of the connection is set. This
  # is configurable because to calculate the true socket peer address
  # a kernel syscall is required which for very fast rack handlers
  # slows down the handling significantly.
  #
  # There are 5 possible values:
  #
  # 1. **:socket** (the default) - read the peername from the socket using the
  #    syscall. This is the normal behavior.
  # 2. **:localhost** - set the remote address to "127.0.0.1"
  # 3. **header: <http_header>**- set the remote address to the value of the
  #    provided http header. For instance:
  #    `set_remote_address header: "X-Real-IP"`.
  #    Only the first word (as separated by spaces or comma) is used, allowing
  #    headers such as X-Forwarded-For to be used as well.
  # 4. **proxy_protocol: :v1**- set the remote address to the value read from the
  #    HAproxy PROXY protocol, version 1. If the request does not have the PROXY
  #    protocol attached to it, will fall back to :socket
  # 5. **\<Any string\>** - this allows you to hardcode remote address to any value
  #    you wish. Because Puma never uses this field anyway, it's format is
  #    entirely in your hands.
  #
  # source://puma//lib/puma/dsl.rb#899
  def set_remote_address(val = T.unsafe(nil)); end

  # When a shutdown is requested, the backtraces of all the
  # threads will be written to $stdout. This can help figure
  # out why shutdown is hanging.
  #
  # source://puma//lib/puma/dsl.rb#859
  def shutdown_debug(val = T.unsafe(nil)); end

  # Disable warning message when running in cluster mode with a single worker.
  #
  # Cluster mode has some overhead of running an additional 'control' process
  # in order to manage the cluster. If only running a single worker it is
  # likely not worth paying that overhead vs running in single mode with
  # additional threads instead.
  #
  # There are some scenarios where running cluster mode with a single worker
  # may still be warranted and valid under certain deployment scenarios, see
  # https://github.com/puma/puma/issues/2534
  #
  # Moving from workers = 1 to workers = 0 will save 10-30% of memory use.
  #
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#530
  def silence_single_worker_warning; end

  # Instead of using +bind+ and manually constructing a URI like:
  #
  #    bind 'ssl://127.0.0.1:9292?key=key_path&cert=cert_path'
  #
  # you can use the this method.
  #
  # When binding on localhost you don't need to specify +cert+ and +key+,
  # Puma will assume you are using the +localhost+ gem and try to load the
  # appropriate files.
  #
  # @example
  #   ssl_bind '127.0.0.1', '9292', {
  #   cert: path_to_cert,
  #   key: path_to_key,
  #   ssl_cipher_filter: cipher_filter, # optional
  #   verify_mode: verify_mode,         # default 'none'
  #   verification_flags: flags,        # optional, not supported by JRuby
  #   }
  # @example Using self-signed certificate with the +localhost+ gem:
  #   ssl_bind '127.0.0.1', '9292'
  # @example Alternatively, you can provide +cert_pem+ and +key_pem+:
  #   ssl_bind '127.0.0.1', '9292', {
  #   cert_pem: File.read(path_to_cert),
  #   key_pem: File.read(path_to_key),
  #   }
  # @example For JRuby, two keys are required: +keystore+ & +keystore_pass+
  #   ssl_bind '127.0.0.1', '9292', {
  #   keystore: path_to_keystore,
  #   keystore_pass: password,
  #   ssl_cipher_list: cipher_list,     # optional
  #   verify_mode: verify_mode          # default 'none'
  #   }
  #
  # source://puma//lib/puma/dsl.rb#480
  def ssl_bind(host, port, opts = T.unsafe(nil)); end

  # Use +path+ as the file to store the server info state. This is
  # used by +pumactl+ to query and control the server.
  #
  # @example
  #   state_path '/u/apps/lolcat/tmp/pids/puma.state'
  #
  # source://puma//lib/puma/dsl.rb#490
  def state_path(path); end

  # Use +permission+ to restrict permissions for the state file.
  #
  # @example
  #   state_permission 0600
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#500
  def state_permission(permission); end

  # Redirect +STDOUT+ and +STDERR+ to files specified. The +append+ parameter
  # specifies whether the output is appended, the default is +false+.
  #
  # @example
  #   stdout_redirect '/app/lolcat/log/stdout', '/app/lolcat/log/stderr'
  # @example
  #   stdout_redirect '/app/lolcat/log/stdout', '/app/lolcat/log/stderr', true
  #
  # source://puma//lib/puma/dsl.rb#408
  def stdout_redirect(stdout = T.unsafe(nil), stderr = T.unsafe(nil), append = T.unsafe(nil)); end

  # Additional text to display in process listing.
  #
  # If you do not specify a tag, Puma will infer it. If you do not want Puma
  # to add a tag, use an empty string.
  #
  # @example
  #   tag 'app name'
  # @example
  #   tag ''
  #
  # source://puma//lib/puma/dsl.rb#750
  def tag(string); end

  # Configure +min+ to be the minimum number of threads to use to answer
  # requests and +max+ the maximum.
  #
  # The default is the environment variables +PUMA_MIN_THREADS+ / +PUMA_MAX_THREADS+
  # (or +MIN_THREADS+ / +MAX_THREADS+ if the +PUMA_+ variables aren't set).
  #
  # If these environment variables aren't set, the default is "0, 5" in MRI or "0, 16" for other interpreters.
  #
  # @example
  #   threads 0, 16
  # @example
  #   threads 5, 5
  #
  # source://puma//lib/puma/dsl.rb#430
  def threads(min, max); end

  # Attempts to route traffic to less-busy workers by causing them to delay
  # listening on the socket, allowing workers which are not processing any
  # requests to pick up new requests first.
  #
  # Only works on MRI. For all other interpreters, this setting does nothing.
  #
  # @see Puma::Server#handle_servers
  # @see Puma::ThreadPool#wait_for_less_busy_worker
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#873
  def wait_for_less_busy_worker(val = T.unsafe(nil)); end

  # Change the default worker timeout for booting.
  #
  # If unspecified, this defaults to the value of worker_timeout.
  #
  # @example
  #   worker_boot_timeout 60
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#ping_timeout
  #
  # source://puma//lib/puma/dsl.rb#800
  def worker_boot_timeout(timeout); end

  # Change the default interval for checking workers.
  #
  # The default value is 5 seconds.
  #
  # @example
  #   worker_check_interval 5
  # @note Cluster mode only.
  # @see Puma::Cluster#check_workers
  #
  # source://puma//lib/puma/dsl.rb#763
  def worker_check_interval(interval); end

  # Set the strategy for worker culling.
  #
  # There are two possible values:
  #
  # 1. **:youngest** - the youngest workers (i.e. the workers that were
  #    the most recently started) will be culled.
  # 2. **:oldest** - the oldest workers (i.e. the workers that were started
  #    the longest time ago) will be culled.
  #
  # @example
  #   worker_culling_strategy :oldest
  # @note Cluster mode only.
  # @see Puma::Cluster#cull_workers
  #
  # source://puma//lib/puma/dsl.rb#827
  def worker_culling_strategy(strategy); end

  # Set the timeout for worker shutdown.
  #
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#term
  #
  # source://puma//lib/puma/dsl.rb#809
  def worker_shutdown_timeout(timeout); end

  # Verifies that all workers have checked in to the master process within
  # the given timeout. If not the worker process will be restarted. This is
  # not a request timeout, it is to protect against a hung or dead process.
  # Setting this value will not protect against slow requests.
  #
  # The minimum value is 6 seconds, the default value is 60 seconds.
  #
  # @example
  #   worker_timeout 60
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#ping_timeout
  #
  # source://puma//lib/puma/dsl.rb#779
  def worker_timeout(timeout); end

  # How many worker processes to run.  Typically this is set to
  # the number of available cores.
  #
  # The default is the value of the environment variable +WEB_CONCURRENCY+ if
  # set, otherwise 0.
  #
  # @note Cluster mode only.
  # @see Puma::Cluster
  #
  # source://puma//lib/puma/dsl.rb#512
  def workers(count); end

  private

  # To avoid adding cert_pem and key_pem as URI params, we store them on the
  # options[:store] from where Puma binder knows how to find and extract them.
  #
  # source://puma//lib/puma/dsl.rb#996
  def add_pem_values_to_options_store(opts); end

  class << self
    # convenience method so logic can be used in CI
    #
    # @see ssl_bind
    #
    # source://puma//lib/puma/dsl.rb#41
    def ssl_bind_str(host, port, opts); end
  end
end

# The implementation of a detailed error logging.
#
# @version 5.0.0
class Puma::ErrorLogger
  include ::Puma::Const

  # @return [ErrorLogger] a new instance of ErrorLogger
  #
  # source://puma//lib/puma/error_logger.rb#16
  def initialize(ioerr); end

  # Print occurred error details only if
  # environment variable PUMA_DEBUG is defined.
  # +options+ hash with additional options:
  # - +error+ is an exception object
  # - +req+ the http request
  # - +text+ (default nil) custom string to print in title
  #   and before all remaining info.
  #
  # source://puma//lib/puma/error_logger.rb#45
  def debug(options = T.unsafe(nil)); end

  # Print occurred error details.
  # +options+ hash with additional options:
  # - +error+ is an exception object
  # - +req+ the http request
  # - +text+ (default nil) custom string to print in title
  #   and before all remaining info.
  #
  # source://puma//lib/puma/error_logger.rb#33
  def info(options = T.unsafe(nil)); end

  # Returns the value of attribute ioerr.
  #
  # source://puma//lib/puma/error_logger.rb#12
  def ioerr; end

  # source://puma//lib/puma/error_logger.rb#71
  def request_dump(req); end

  # source://puma//lib/puma/error_logger.rb#87
  def request_headers(req); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/error_logger.rb#92
  def request_parsed?(req); end

  # source://puma//lib/puma/error_logger.rb#76
  def request_title(req); end

  # source://puma//lib/puma/error_logger.rb#59
  def title(options = T.unsafe(nil)); end

  private

  # source://puma//lib/puma/error_logger.rb#98
  def log(str); end

  class << self
    # source://puma//lib/puma/error_logger.rb#22
    def stdio; end
  end
end

# source://puma//lib/puma/error_logger.rb#14
Puma::ErrorLogger::REQUEST_FORMAT = T.let(T.unsafe(nil), String)

# The default implement of an event sink object used by Server
# for when certain kinds of events occur in the life of the server.
#
# The methods available are the events that the Server fires.
class Puma::Events
  # Create an Events object that prints to +stdout+ and +stderr+.
  #
  # @return [Events] a new instance of Events
  #
  # source://puma//lib/puma/events.rb#28
  def initialize(stdout, stderr); end

  # An HTTP connection error has occurred.
  # +error+ a connection exception, +req+ the request,
  # and +text+ additional info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/events.rb#95
  def connection_error(error, req, text = T.unsafe(nil)); end

  # source://puma//lib/puma/events.rb#75
  def debug(str); end

  # Log occurred error debug dump.
  # +error+ an exception object, +req+ the request,
  # and +text+ additional info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/events.rb#131
  def debug_error(error, req = T.unsafe(nil), text = T.unsafe(nil)); end

  # Write +str+ to +@stderr+
  #
  # source://puma//lib/puma/events.rb#81
  def error(str); end

  # Fire callbacks for the named hook
  #
  # source://puma//lib/puma/events.rb#44
  def fire(hook, *args); end

  # source://puma//lib/puma/events.rb#147
  def fire_on_booted!; end

  # source://puma//lib/puma/events.rb#151
  def fire_on_restart!; end

  # source://puma//lib/puma/events.rb#155
  def fire_on_stopped!; end

  # source://puma//lib/puma/events.rb#86
  def format(str); end

  # Returns the value of attribute formatter.
  #
  # source://puma//lib/puma/events.rb#40
  def formatter; end

  # Sets the attribute formatter
  #
  # @param value the value to set the attribute formatter to.
  #
  # source://puma//lib/puma/events.rb#40
  def formatter=(_arg0); end

  # Write +str+ to +@stdout+
  #
  # source://puma//lib/puma/events.rb#64
  def log(str); end

  # source://puma//lib/puma/events.rb#135
  def on_booted(&block); end

  # source://puma//lib/puma/events.rb#139
  def on_restart(&block); end

  # source://puma//lib/puma/events.rb#143
  def on_stopped(&block); end

  # An HTTP parse error has occurred.
  # +error+ a parsing exception,
  # and +req+ the request.
  #
  # source://puma//lib/puma/events.rb#103
  def parse_error(error, req); end

  # Register a callback for a given hook
  #
  # source://puma//lib/puma/events.rb#50
  def register(hook, obj = T.unsafe(nil), &blk); end

  # An SSL error has occurred.
  #
  # @param error [Puma::MiniSSL::SSLError]
  # @param ssl_socket [Puma::MiniSSL::Socket]
  #
  # source://puma//lib/puma/events.rb#111
  def ssl_error(error, ssl_socket); end

  # Returns the value of attribute stderr.
  #
  # source://puma//lib/puma/events.rb#39
  def stderr; end

  # Returns the value of attribute stdout.
  #
  # source://puma//lib/puma/events.rb#39
  def stdout; end

  # An unknown error has occurred.
  # +error+ an exception object, +req+ the request,
  # and +text+ additional info
  #
  # source://puma//lib/puma/events.rb#122
  def unknown_error(error, req = T.unsafe(nil), text = T.unsafe(nil)); end

  # source://puma//lib/puma/events.rb#71
  def write(str); end

  class << self
    # source://puma//lib/puma/events.rb#172
    def null; end

    # source://puma//lib/puma/events.rb#168
    def stdio; end

    # Returns an Events object which writes its status to 2 StringIO
    # objects.
    #
    # source://puma//lib/puma/events.rb#164
    def strings; end
  end
end

# source://puma//lib/puma/events.rb#159
Puma::Events::DEFAULT = T.let(T.unsafe(nil), Puma::Events)

class Puma::Events::DefaultFormatter
  # source://puma//lib/puma/events.rb#15
  def call(str); end
end

class Puma::Events::PidFormatter
  # source://puma//lib/puma/events.rb#21
  def call(str); end
end

# @version 5.2.1
#
# source://puma//lib/puma/detect.rb#9
Puma::HAS_FORK = T.let(T.unsafe(nil), TrueClass)

# at present, MiniSSL::Engine is only defined in extension code (puma_http11),
# not in minissl.rb
#
# source://puma//lib/puma.rb#24
Puma::HAS_SSL = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma.rb#26
Puma::HAS_UNIX_SOCKET = T.let(T.unsafe(nil), TrueClass)

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
# curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#   ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#             puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
#
# source://puma//lib/puma/const.rb#18
Puma::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Puma::HttpParser
  def initialize; end

  def body; end
  def error?; end
  def execute(_arg0, _arg1, _arg2); end
  def finish; end
  def finished?; end
  def nread; end
  def reset; end
end

class Puma::HttpParserError < ::IOError; end
class Puma::HttpParserError501 < ::IOError; end

class Puma::IOBuffer < ::String
  # source://puma//lib/puma/io_buffer.rb#5
  def append(*args); end

  def reset; end
end

# source://puma//lib/puma/detect.rb#11
Puma::IS_JRUBY = T.let(T.unsafe(nil), FalseClass)

# @version 5.2.0
#
# source://puma//lib/puma/detect.rb#19
Puma::IS_MRI = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma/detect.rb#13
Puma::IS_OSX = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma/detect.rb#15
Puma::IS_WINDOWS = T.let(T.unsafe(nil), FalseClass)

# Puma deliberately avoids the use of the json gem and instead performs JSON
# serialization without any external dependencies. In a puma cluster, loading
# any gem into the puma master process means that operators cannot use a
# phased restart to upgrade their application if the new version of that
# application uses a different version of that gem. The json gem in
# particular is additionally problematic because it leverages native
# extensions. If the puma master process relies on a gem with native
# extensions and operators remove gems from disk related to old releases,
# subsequent phased restarts can fail.
#
# The implementation of JSON serialization in this module is not designed to
# be particularly full-featured or fast. It just has to handle the few places
# where Puma relies on JSON serialization internally.
module Puma::JSONSerialization
  class << self
    # source://puma//lib/puma/json_serialization.rb#29
    def generate(value); end

    private

    # source://puma//lib/puma/json_serialization.rb#86
    def serialize_object_key(output, value); end

    # source://puma//lib/puma/json_serialization.rb#71
    def serialize_string(output, value); end

    # source://puma//lib/puma/json_serialization.rb#38
    def serialize_value(output, value); end
  end
end

# source://puma//lib/puma/json_serialization.rb#22
Puma::JSONSerialization::BACKSLASH = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/json_serialization.rb#24
Puma::JSONSerialization::CHAR_TO_ESCAPE = T.let(T.unsafe(nil), Regexp)

# As required by ECMA-404
#
# source://puma//lib/puma/json_serialization.rb#23
Puma::JSONSerialization::CONTROL_CHAR_TO_ESCAPE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/json_serialization.rb#21
Puma::JSONSerialization::QUOTE = T.let(T.unsafe(nil), Regexp)

class Puma::JSONSerialization::SerializationError < ::StandardError; end

# Puma::Launcher is the single entry point for starting a Puma server based on user
# configuration. It is responsible for taking user supplied arguments and resolving them
# with configuration in `config/puma.rb` or `config/puma/<env>.rb`.
#
# It is responsible for either launching a cluster of Puma workers or a single
# puma server.
class Puma::Launcher
  # Returns an instance of Launcher
  #
  # +conf+ A Puma::Configuration object indicating how to run the server.
  #
  # +launcher_args+ A Hash that currently has one required key `:events`,
  # this is expected to hold an object similar to an `Puma::Events.stdio`,
  # this object will be responsible for broadcasting Puma's internal state
  # to a logging destination. An optional key `:argv` can be supplied,
  # this should be an array of strings, these arguments are re-used when
  # restarting the puma server.
  #
  # Examples:
  #
  #   conf = Puma::Configuration.new do |user_config|
  #     user_config.threads 1, 10
  #     user_config.app do |env|
  #       [200, {}, ["hello world"]]
  #     end
  #   end
  #   Puma::Launcher.new(conf, events: Puma::Events.stdio).run
  #
  # @return [Launcher] a new instance of Launcher
  #
  # source://puma//lib/puma/launcher.rb#44
  def initialize(conf, launcher_args = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/launcher.rb#102
  def binder; end

  # source://puma//lib/puma/launcher.rb#229
  def close_binder_listeners; end

  # Returns the value of attribute config.
  #
  # source://puma//lib/puma/launcher.rb#102
  def config; end

  # Return all tcp ports the launcher may be using, TCP or SSL
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/launcher.rb#215
  def connected_ports; end

  # Delete the configured pidfile
  #
  # source://puma//lib/puma/launcher.rb#130
  def delete_pidfile; end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/launcher.rb#102
  def events; end

  # Begin async shutdown of the server
  #
  # source://puma//lib/puma/launcher.rb#136
  def halt; end

  # Returns the value of attribute options.
  #
  # source://puma//lib/puma/launcher.rb#102
  def options; end

  # Begin a phased restart if supported
  #
  # source://puma//lib/puma/launcher.rb#154
  def phased_restart; end

  # Begin a refork if supported
  #
  # source://puma//lib/puma/launcher.rb#163
  def refork; end

  # Begin async restart of the server
  #
  # source://puma//lib/puma/launcher.rb#148
  def restart; end

  # source://puma//lib/puma/launcher.rb#220
  def restart_args; end

  # Returns the value of attribute restart_dir.
  #
  # source://puma//lib/puma/launcher.rb#102
  def restart_dir; end

  # Run the server. This blocks until the server is stopped
  #
  # source://puma//lib/puma/launcher.rb#174
  def run; end

  # Return stats about the server
  #
  # source://puma//lib/puma/launcher.rb#105
  def stats; end

  # Begin async shutdown of the server gracefully
  #
  # source://puma//lib/puma/launcher.rb#142
  def stop; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/launcher.rb#240
  def thread_status; end

  # Write a state file that can be used by pumactl to control
  # the server
  #
  # source://puma//lib/puma/launcher.rb#111
  def write_state; end

  private

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#383
  def clustered?; end

  # source://puma//lib/puma/launcher.rb#414
  def environment; end

  # source://puma//lib/puma/launcher.rb#301
  def extra_runtime_deps_directories; end

  # source://puma//lib/puma/launcher.rb#294
  def files_to_require_after_prune; end

  # source://puma//lib/puma/launcher.rb#422
  def generate_restart_data; end

  # source://puma//lib/puma/launcher.rb#392
  def graceful_stop; end

  # Puma's systemd integration allows Puma to inform systemd:
  #  1. when it has successfully started
  #  2. when it is starting shutdown
  #  3. periodically for a liveness check with a watchdog thread
  #
  # source://puma//lib/puma/launcher.rb#354
  def integrate_with_systemd; end

  # source://puma//lib/puma/launcher.rb#379
  def log(str); end

  # source://puma//lib/puma/launcher.rb#548
  def log_config; end

  # source://puma//lib/puma/launcher.rb#320
  def prune_bundler; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#418
  def prune_bundler?; end

  # source://puma//lib/puma/launcher.rb#313
  def puma_wild_location; end

  # source://puma//lib/puma/launcher.rb#265
  def reload_worker_directory; end

  # source://puma//lib/puma/launcher.rb#375
  def require_paths_for_gem(gem_spec); end

  # source://puma//lib/puma/launcher.rb#531
  def require_rubygems_min_version!(min_version, feature); end

  # source://puma//lib/puma/launcher.rb#269
  def restart!; end

  # source://puma//lib/puma/launcher.rb#397
  def set_process_title; end

  # source://puma//lib/puma/launcher.rb#408
  def set_rack_environment; end

  # source://puma//lib/puma/launcher.rb#467
  def setup_signals; end

  # source://puma//lib/puma/launcher.rb#371
  def spec_for_gem(gem_name); end

  # source://puma//lib/puma/launcher.rb#402
  def title; end

  # @raise [UnsupportedOption]
  #
  # source://puma//lib/puma/launcher.rb#387
  def unsupported(str); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/launcher.rb#539
  def with_unbundled_env; end

  # If configured, write the pid of the current process out
  # to a file.
  #
  # source://puma//lib/puma/launcher.rb#255
  def write_pid; end
end

# @deprecated 6.0.0
#
# source://puma//lib/puma/launcher.rb#19
Puma::Launcher::KEYS_NOT_TO_PERSIST_IN_STATE = T.let(T.unsafe(nil), Array)

module Puma::MiniSSL
  class << self
    def check; end
  end
end

class Puma::MiniSSL::Context
  # @return [Context] a new instance of Context
  #
  # source://puma//lib/puma/minissl.rb#208
  def initialize; end

  # Returns the value of attribute ca.
  #
  # source://puma//lib/puma/minissl.rb#241
  def ca; end

  # source://puma//lib/puma/minissl.rb#257
  def ca=(ca); end

  # Returns the value of attribute cert.
  #
  # source://puma//lib/puma/minissl.rb#240
  def cert; end

  # source://puma//lib/puma/minissl.rb#252
  def cert=(cert); end

  # Returns the value of attribute cert_pem.
  #
  # source://puma//lib/puma/minissl.rb#242
  def cert_pem; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#262
  def cert_pem=(cert_pem); end

  # source://puma//lib/puma/minissl.rb#272
  def check; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#217
  def check_file(file, desc); end

  # non-jruby Context properties
  #
  # source://puma//lib/puma/minissl.rb#239
  def key; end

  # source://puma//lib/puma/minissl.rb#247
  def key=(key); end

  # Returns the value of attribute key_pem.
  #
  # source://puma//lib/puma/minissl.rb#243
  def key_pem; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#267
  def key_pem=(key_pem); end

  # Returns the value of attribute no_tlsv1.
  #
  # source://puma//lib/puma/minissl.rb#206
  def no_tlsv1; end

  # disables TLSv1
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#280
  def no_tlsv1=(tlsv1); end

  # Returns the value of attribute no_tlsv1_1.
  #
  # source://puma//lib/puma/minissl.rb#206
  def no_tlsv1_1; end

  # disables TLSv1 and TLSv1.1.  Overrides `#no_tlsv1=`
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#287
  def no_tlsv1_1=(tlsv1_1); end

  # Returns the value of attribute ssl_cipher_filter.
  #
  # source://puma//lib/puma/minissl.rb#244
  def ssl_cipher_filter; end

  # Sets the attribute ssl_cipher_filter
  #
  # @param value the value to set the attribute ssl_cipher_filter to.
  #
  # source://puma//lib/puma/minissl.rb#244
  def ssl_cipher_filter=(_arg0); end

  # Returns the value of attribute verification_flags.
  #
  # source://puma//lib/puma/minissl.rb#245
  def verification_flags; end

  # Sets the attribute verification_flags
  #
  # @param value the value to set the attribute verification_flags to.
  #
  # source://puma//lib/puma/minissl.rb#245
  def verification_flags=(_arg0); end

  # Returns the value of attribute verify_mode.
  #
  # source://puma//lib/puma/minissl.rb#205
  def verify_mode; end

  # Sets the attribute verify_mode
  #
  # @param value the value to set the attribute verify_mode to.
  #
  # source://puma//lib/puma/minissl.rb#205
  def verify_mode=(_arg0); end
end

class Puma::MiniSSL::ContextBuilder
  # @return [ContextBuilder] a new instance of ContextBuilder
  #
  # source://puma//lib/puma/minissl/context_builder.rb#4
  def initialize(params, events); end

  # source://puma//lib/puma/minissl/context_builder.rb#9
  def context; end

  private

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#78
  def events; end

  # Returns the value of attribute params.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#78
  def params; end
end

class Puma::MiniSSL::Engine
  def extract; end
  def init?; end
  def inject(_arg0); end
  def peercert; end
  def read; end
  def shutdown; end
  def ssl_vers_st; end
  def write(_arg0); end

  class << self
    def client; end
    def server(_arg0); end
  end
end

# Define constant at runtime, as it's easy to determine at built time,
# but Puma could (it shouldn't) be loaded with an older OpenSSL version
#
# @version 5.0.0
#
# source://puma//lib/puma/minissl.rb#16
Puma::MiniSSL::HAS_TLS1_3 = T.let(T.unsafe(nil), TrueClass)

Puma::MiniSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
Puma::MiniSSL::OPENSSL_NO_SSL3 = T.let(T.unsafe(nil), TrueClass)
Puma::MiniSSL::OPENSSL_NO_TLS1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_NO_TLS1_1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)

class Puma::MiniSSL::SSLContext
  def initialize(_arg0); end
end

# this class is defined so that it exists when Puma is compiled
# without ssl support, as Server and Reactor use it in rescue statements.
class Puma::MiniSSL::SSLError < ::StandardError; end

class Puma::MiniSSL::Server
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/minissl.rb#325
  def initialize(socket, ctx); end

  # source://puma//lib/puma/minissl.rb#331
  def accept; end

  # source://puma//lib/puma/minissl.rb#338
  def accept_nonblock; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#352
  def addr; end

  # source://puma//lib/puma/minissl.rb#356
  def close; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#360
  def closed?; end

  # source://puma//lib/puma/minissl.rb#346
  def to_io; end
end

class Puma::MiniSSL::Socket
  # @return [Socket] a new instance of Socket
  #
  # source://puma//lib/puma/minissl.rb#21
  def initialize(socket, engine); end

  # source://puma//lib/puma/minissl.rb#117
  def <<(data); end

  # source://puma//lib/puma/minissl.rb#164
  def close; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#32
  def closed?; end

  # source://puma//lib/puma/minissl.rb#74
  def engine_read_all; end

  # source://puma//lib/puma/minissl.rb#160
  def flush; end

  # source://puma//lib/puma/minissl.rb#180
  def peeraddr; end

  # source://puma//lib/puma/minissl.rb#185
  def peercert; end

  # source://puma//lib/puma/minissl.rb#82
  def read_nonblock(size, *_); end

  # source://puma//lib/puma/minissl.rb#57
  def readpartial(size); end

  # Returns a two element array,
  # first is protocol version (SSL_get_version),
  # second is 'handshake' state (SSL_state_string)
  #
  # Used for dropping tcp connections to ssl.
  # See OpenSSL ssl/ssl_stat.c SSL_state_string for info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#45
  def ssl_version_state; end

  # source://puma//lib/puma/minissl.rb#117
  def syswrite(data); end

  # source://puma//lib/puma/minissl.rb#28
  def to_io; end

  # source://puma//lib/puma/minissl.rb#117
  def write(data); end

  # The problem with implementing it properly
  # is that it means we'd have to have the ability to rewind
  # an engine because after we write+extract, the socket
  # write_nonblock call might raise an exception and later
  # code would pass the same data in, but the engine would think
  # it had already written the data in.
  #
  # So for the time being (and since write blocking is quite rare),
  # go ahead and actually block in write_nonblock.
  #
  # source://puma//lib/puma/minissl.rb#156
  def write_nonblock(data, *_); end

  private

  # Used to check the handshake status, in particular when a TCP connection
  # is made with TLSv1.3 as an available protocol
  #
  # @return [Boolean]
  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#52
  def bad_tlsv1_3?; end
end

# https://github.com/openssl/openssl/blob/master/include/openssl/x509_vfy.h.in
# /* Certificate verify flags */
#
# source://puma//lib/puma/minissl.rb#300
Puma::MiniSSL::VERIFICATION_FLAGS = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/minissl.rb#296
Puma::MiniSSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#294
Puma::MiniSSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#295
Puma::MiniSSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

# Provides an IO-like object that always appears to contain no data.
# Used as the value for rack.input when the request has no body.
class Puma::NullIO
  # source://puma//lib/puma/null_io.rb#28
  def close; end

  # This is used as singleton class, so can't have state.
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#57
  def closed?; end

  # source://puma//lib/puma/null_io.rb#16
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#35
  def eof?; end

  # source://puma//lib/puma/null_io.rb#52
  def flush; end

  # source://puma//lib/puma/null_io.rb#8
  def gets; end

  # source://puma//lib/puma/null_io.rb#46
  def puts(*ary); end

  # Mimics IO#read with no data.
  #
  # source://puma//lib/puma/null_io.rb#21
  def read(count = T.unsafe(nil), _buffer = T.unsafe(nil)); end

  # source://puma//lib/puma/null_io.rb#25
  def rewind; end

  # source://puma//lib/puma/null_io.rb#31
  def size; end

  # source://puma//lib/puma/null_io.rb#12
  def string; end

  # source://puma//lib/puma/null_io.rb#39
  def sync; end

  # source://puma//lib/puma/null_io.rb#43
  def sync=(v); end

  # source://puma//lib/puma/null_io.rb#49
  def write(*ary); end
end

class Puma::Plugin
  # source://puma//lib/puma/plugin.rb#107
  def in_background(&blk); end

  class << self
    # source://puma//lib/puma/plugin.rb#97
    def create(&blk); end

    # source://puma//lib/puma/plugin.rb#90
    def extract_name(ary); end
  end
end

# Matches
#  "C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb:3:in `<top (required)>'"
#  AS
#  C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb
#
# source://puma//lib/puma/plugin.rb#81
Puma::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

class Puma::PluginLoader
  # @return [PluginLoader] a new instance of PluginLoader
  #
  # source://puma//lib/puma/plugin.rb#7
  def initialize; end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#11
  def create(name); end

  # source://puma//lib/puma/plugin.rb#21
  def fire_starts(launcher); end
end

class Puma::PluginRegistry
  # @return [PluginRegistry] a new instance of PluginRegistry
  #
  # source://puma//lib/puma/plugin.rb#31
  def initialize; end

  # source://puma//lib/puma/plugin.rb#60
  def add_background(blk); end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#40
  def find(name); end

  # source://puma//lib/puma/plugin.rb#64
  def fire_background; end

  # source://puma//lib/puma/plugin.rb#36
  def register(name, cls); end
end

# source://puma//lib/puma/plugin.rb#74
Puma::Plugins = T.let(T.unsafe(nil), Puma::PluginRegistry)

module Puma::Rack; end

# Rack::Builder implements a small DSL to iteratively construct Rack
# applications.
#
# Example:
#
#  require 'rack/lobster'
#  app = Rack::Builder.new do
#    use Rack::CommonLogger
#    use Rack::ShowExceptions
#    map "/lobster" do
#      use Rack::Lint
#      run Rack::Lobster.new
#    end
#  end
#
#  run app
#
# Or
#
#  app = Rack::Builder.app do
#    use Rack::CommonLogger
#    run lambda { |env| [200, {'Content-Type' => 'text/plain'}, ['OK']] }
#  end
#
#  run app
#
# +use+ adds middleware to the stack, +run+ dispatches to an application.
# You can use +map+ to construct a Rack::URLMap in a convenient way.
class Puma::Rack::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://puma//lib/puma/rack/builder.rb#176
  def initialize(default_app = T.unsafe(nil), &block); end

  # source://puma//lib/puma/rack/builder.rb#283
  def call(env); end

  # Creates a route within the application.
  #
  #   Rack::Builder.app do
  #     map '/' do
  #       run Heartbeat
  #     end
  #   end
  #
  # The +use+ method can also be used here to specify middleware to run under a specific path:
  #
  #   Rack::Builder.app do
  #     map '/' do
  #       use Middleware
  #       run Heartbeat
  #     end
  #   end
  #
  # This example includes a piece of middleware which will run before requests hit +Heartbeat+.
  #
  # source://puma//lib/puma/rack/builder.rb#270
  def map(path, &block); end

  # Takes an argument that is an object that responds to #call and returns a Rack response.
  # The simplest form of this is a lambda object:
  #
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # However this could also be a class:
  #
  #   class Heartbeat
  #     def self.call(env)
  #      [200, { "Content-Type" => "text/plain" }, ["OK"]]
  #    end
  #   end
  #
  #   run Heartbeat
  #
  # source://puma//lib/puma/rack/builder.rb#234
  def run(app); end

  # source://puma//lib/puma/rack/builder.rb#275
  def to_app; end

  # Specifies middleware to use in a stack.
  #
  #   class Middleware
  #     def initialize(app)
  #       @app = app
  #     end
  #
  #     def call(env)
  #       env["rack.some_header"] = "setting an example"
  #       @app.call(env)
  #     end
  #   end
  #
  #   use Middleware
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # All requests through to this application will first be processed by the middleware class.
  # The +call+ method in this example sets an additional environment key which then can be
  # referenced in the application if required.
  #
  # source://puma//lib/puma/rack/builder.rb#212
  def use(middleware, *args, &block); end

  # Takes a lambda or block that is used to warm-up the application.
  #
  #   warmup do |app|
  #     client = Rack::MockRequest.new(app)
  #     client.get('/')
  #   end
  #
  #   use SomeMiddleware
  #   run MyApp
  #
  # source://puma//lib/puma/rack/builder.rb#247
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # source://puma//lib/puma/rack/builder.rb#289
  def generate_map(default_app, mapping); end

  class << self
    # source://puma//lib/puma/rack/builder.rb#189
    def app(default_app = T.unsafe(nil), &block); end

    # source://puma//lib/puma/rack/builder.rb#171
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # source://puma//lib/puma/rack/builder.rb#155
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

class Puma::Rack::Options
  # source://puma//lib/puma/rack/builder.rb#101
  def handler_opts(options); end

  # source://puma//lib/puma/rack/builder.rb#8
  def parse!(args); end
end

# Monitors a collection of IO objects, calling a block whenever
# any monitored object either receives data or times out, or when the Reactor shuts down.
#
# The waiting/wake up is performed with nio4r, which will use the appropriate backend (libev,
# Java NIO or just plain IO#select). The call to `NIO::Selector#select` will
# 'wakeup' any IO object that receives data.
#
# This class additionally tracks a timeout for every added object,
# and wakes up any object when its timeout elapses.
#
# The implementation uses a Queue to synchronize adding new objects from the internal select loop.
class Puma::Reactor
  # Create a new Reactor to monitor IO objects added by #add.
  # The provided block will be invoked when an IO has data available to read,
  # its timeout elapses, or when the Reactor shuts down.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://puma//lib/puma/reactor.rb#23
  def initialize(backend, &block); end

  # Add a new client to monitor.
  # The object must respond to #timeout and #timeout_at.
  # Returns false if the reactor is already shut down.
  #
  # source://puma//lib/puma/reactor.rb#49
  def add(client); end

  # Run the internal select loop, using a background thread by default.
  #
  # source://puma//lib/puma/reactor.rb#35
  def run(background = T.unsafe(nil)); end

  # Shutdown the reactor, blocking until the background thread is finished.
  #
  # source://puma//lib/puma/reactor.rb#58
  def shutdown; end

  private

  # Start monitoring the object.
  #
  # source://puma//lib/puma/reactor.rb#100
  def register(client); end

  # source://puma//lib/puma/reactor.rb#69
  def select_loop; end

  # 'Wake up' a monitored object by calling the provided block.
  # Stop monitoring the object if the block returns `true`.
  #
  # source://puma//lib/puma/reactor.rb#109
  def wakeup!(client); end
end

# The methods here are included in Server, but are separated into this file.
# All the methods here pertain to passing the request to the app, then
# writing the response back to the client.
#
# None of the methods here are called externally, with the exception of
# #handle_request, which is called in Server#process_client.
#
# @version 5.0.3
module Puma::Request
  include ::Puma::Const

  # @param env [Hash] see Puma::Client#env, from request
  # @return [Puma::Const::PORT_443, Puma::Const::PORT_80]
  #
  # source://puma//lib/puma/request.rb#194
  def default_server_port(env); end

  # Takes the request contained in +client+, invokes the Rack application to construct
  # the response and writes it back to +client.io+.
  #
  # It'll return +false+ when the connection is closed, this doesn't mean
  # that the response wasn't successful.
  #
  # It'll return +:async+ if the connection remains open but will be handled
  # elsewhere, i.e. the connection has been hijacked by the Rack application.
  #
  # Finally, it'll return +true+ on keep-alive connections.
  #
  # @param client [Puma::Client]
  # @param lines [Puma::IOBuffer]
  # @param requests [Integer]
  # @return [Boolean, :async]
  #
  # source://puma//lib/puma/request.rb#32
  def handle_request(client, lines, requests); end

  # Given a Hash +env+ for the request read from +client+, add
  # and fixup keys to comply with Rack's env guidelines.
  #
  # @param env [Hash] see Puma::Client#env, from request
  # @param client [Puma::Client] only needed for Client#peerip
  # @todo make private in 6.0.0
  #
  # source://puma//lib/puma/request.rb#242
  def normalize_env(env, client); end

  private

  # Writes to an io (normally Client#io) using #syswrite
  #
  # @param io [#syswrite] the io to write to
  # @param str [String] the string written to the io
  # @raise [ConnectionError]
  #
  # source://puma//lib/puma/request.rb#207
  def fast_write(io, str); end

  # @param status [Integer] status from the app
  # @return [String] the text description from Puma::HTTP_STATUS_CODES
  #
  # source://puma//lib/puma/request.rb#231
  def fetch_status_code(status); end

  # @param header_key [#to_s]
  # @return [Boolean]
  #
  # source://puma//lib/puma/request.rb#303
  def illegal_header_key?(header_key); end

  # @param header_value [#to_s]
  # @return [Boolean]
  #
  # source://puma//lib/puma/request.rb#310
  def illegal_header_value?(header_value); end

  # Fixup any headers with `,` in the name to have `_` now. We emit
  # headers with `,` in them during the parse phase to avoid ambiguity
  # with the `-` to `_` conversion for critical headers. But here for
  # compatibility, we'll convert them back. This code is written to
  # avoid allocation in the common case (ie there are no headers
  # with `,` in their names), that's why it has the extra conditionals.
  #
  # @param env [Hash] see Puma::Client#env, from request, modifies in place
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#324
  def req_env_post_parse(env); end

  # Used in the lambda for env[ `Puma::Const::EARLY_HINTS` ]
  #
  # @param headers [Hash] the headers returned by the Rack application
  # @return [String]
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#356
  def str_early_hints(headers); end

  # Processes and write headers to the IOBuffer.
  #
  # @param env [Hash] see Puma::Client#env, from request
  # @param status [Integer] the status returned by the Rack application
  # @param headers [Hash] the headers returned by the Rack application
  # @param res_info [Hash] used to pass info between this method and #handle_request
  # @param lines [Puma::IOBuffer] modified inn place
  # @param requests [Integer] number of inline requests handled
  # @param client [Puma::Client]
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#384
  def str_headers(env, status, headers, res_info, lines, requests, client); end
end

# Generic class that is used by `Puma::Cluster` and `Puma::Single` to
# serve requests. This class spawns a new instance of `Puma::Server` via
# a call to `start_server`.
class Puma::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://puma//lib/puma/runner.rb#11
  def initialize(cli, events); end

  # source://puma//lib/puma/runner.rb#160
  def app; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/runner.rb#77
  def close_control_listeners; end

  # source://puma//lib/puma/runner.rb#51
  def debug(str); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#30
  def development?; end

  # source://puma//lib/puma/runner.rb#47
  def error(str); end

  # source://puma//lib/puma/runner.rb#143
  def load_and_bind; end

  # source://puma//lib/puma/runner.rb#38
  def log(str); end

  # source://puma//lib/puma/runner.rb#94
  def output_header(mode); end

  # source://puma//lib/puma/runner.rb#116
  def redirect_io; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#112
  def redirected_io?; end

  # source://puma//lib/puma/runner.rb#82
  def ruby_engine; end

  # source://puma//lib/puma/runner.rb#55
  def start_control; end

  # source://puma//lib/puma/runner.rb#164
  def start_server; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/runner.rb#43
  def stop_control; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#34
  def test?; end

  # source://puma//lib/puma/runner.rb#21
  def wakeup!; end

  private

  # source://puma//lib/puma/runner.rb#171
  def ensure_output_directory_exists(path, io_name); end
end

# For some HTTP status codes the client only expects headers.
#
# source://puma//lib/puma/const.rb#84
Puma::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# The HTTP Server itself. Serves out a single Rack app.
#
# This class is used by the `Puma::Single` and `Puma::Cluster` classes
# to generate one or more `Puma::Server` instances capable of handling requests.
# Each Puma process will contain one `Puma::Server` instance.
#
# The `Puma::Server` instance pulls requests from the socket, adds them to a
# `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.
#
# Each `Puma::Server` will have one reactor and one thread pool.
class Puma::Server
  include ::Puma::Const
  include ::Puma::Request
  extend ::Forwardable

  # Create a server for the rack app +app+.
  #
  # +events+ is an object which will be called when certain error events occur
  # to be handled. See Puma::Events for the list of current methods to implement.
  #
  # Server#run returns a thread that you can join on to wait for the server
  # to do its work.
  #
  # @note Several instance variables exist so they are available for testing,
  #   and have default values set via +fetch+.  Normally the values are set via
  #   `::Puma::Configuration.puma_default_options`.
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/server.rb#74
  def initialize(app, events = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_ssl_listener(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_tcp_listener(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def add_unix_listener(*args, **_arg1, &block); end

  # Returns the value of attribute app.
  #
  # source://puma//lib/puma/server.rb#54
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://puma//lib/puma/server.rb#54
  def app=(_arg0); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def auto_trim_time; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def auto_trim_time=(_arg0); end

  # source://puma//lib/puma/server.rb#197
  def backlog; end

  # source://puma//lib/puma/server.rb#609
  def begin_restart(sync = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/server.rb#55
  def binder; end

  # Sets the attribute binder
  #
  # @param value the value to set the attribute binder to.
  #
  # source://puma//lib/puma/server.rb#55
  def binder=(_arg0); end

  # Handle various error types thrown by Client I/O operations.
  #
  # source://puma//lib/puma/server.rb#509
  def client_error(e, client); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#191
  def closed_socket?(socket); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def connected_ports(*args, **_arg1, &block); end

  # 6 == Socket::IPPROTO_TCP
  # 3 == TCP_CORK
  # 1/0 == turn on/off
  #
  # source://puma//lib/puma/server.rb#164
  def cork_socket(socket); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def early_hints; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def early_hints=(_arg0); end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/server.rb#39
  def events; end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def first_data_timeout; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def first_data_timeout=(_arg0); end

  # Wait for all outstanding requests to finish.
  #
  # source://puma//lib/puma/server.rb#552
  def graceful_shutdown; end

  # source://puma//lib/puma/server.rb#604
  def halt(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#389
  def handle_check; end

  # source://puma//lib/puma/server.rb#312
  def handle_servers; end

  # source://puma//lib/puma/server.rb#113
  def inherit_binder(bind); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def leak_stack_on_error; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def leak_stack_on_error=(_arg0); end

  # to help with backports
  #
  # source://puma//lib/puma/server.rb#42
  def log_writer; end

  # A fallback rack response if +@app+ raises as exception.
  #
  # source://puma//lib/puma/server.rb#531
  def lowlevel_error(e, env, status = T.unsafe(nil)); end

  # for #stats
  #
  # source://puma//lib/puma/server.rb#40
  def max_threads; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def max_threads=(_arg0); end

  # for #stats
  #
  # source://puma//lib/puma/server.rb#40
  def min_threads; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def min_threads=(_arg0); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def persistent_timeout; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def persistent_timeout=(_arg0); end

  # This number represents the number of requests that
  # the server is capable of taking right now.
  #
  # For example if the number is 5 then it means
  # there are 5 threads sitting idle ready to take
  # a request. If one request comes in, then the
  # value would be 4 until it finishes processing.
  #
  # source://puma//lib/puma/server.rb#215
  def pool_capacity; end

  # Given a connection on +client+, handle the incoming requests,
  # or queue the connection in the Reactor if no request is available.
  #
  # This method is called from a ThreadPool worker thread.
  #
  # This method supports HTTP Keep-Alive so it may, depending on if the client
  # indicates that it supports keep alive, wait for another request before
  # returning.
  #
  # Return true if one or more requests were processed.
  #
  # source://puma//lib/puma/server.rb#417
  def process_client(client, buffer); end

  # This method is called from the Reactor thread when a queued Client receives data,
  # times out, or when the Reactor is shutting down.
  #
  # It is responsible for ensuring that a request has been completely received
  # before it starts to be processed by the ThreadPool. This may be known as read buffering.
  # If read buffering is not done, and no other read buffering is performed (such as by an application server
  # such as nginx) then the application would be subject to a slow client attack.
  #
  # For a graphical representation of how the request buffer works see [architecture.md](https://github.com/puma/puma/blob/master/docs/architecture.md#connection-pipeline).
  #
  # The method checks to see if it has the full header and body with
  # the `Puma::Client#try_to_finish` method. If the full request has been sent,
  # then the request is passed to the ThreadPool (`@thread_pool << client`)
  # so that a "worker thread" can pick up the request and begin to execute application logic.
  # The Client is then removed from the reactor (return `true`).
  #
  # If a client object times out, a 408 response is written, its connection is closed,
  # and the object is removed from the reactor (return `true`).
  #
  # If the Reactor is shutting down, all Clients are either timed out or passed to the
  # ThreadPool, depending on their current state (#can_close?).
  #
  # Otherwise, if the full request is not ready then the client will remain in the reactor
  # (return `false`). When the client sends more data to the socket the `Puma::Client` object
  # will wake up and again be checked to see if it's ready to be passed to the thread pool.
  #
  # source://puma//lib/puma/server.rb#296
  def reactor_wakeup(client); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#45
  def reaping_time; end

  # @deprecated v6.0.0
  #
  # source://puma//lib/puma/server.rb#50
  def reaping_time=(_arg0); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/server.rb#41
  def requests_count; end

  # Runs the server.
  #
  # If +background+ is true (the default) then a thread is spun
  # up in the background to handle requests. Otherwise requests
  # are handled synchronously.
  #
  # source://puma//lib/puma/server.rb#225
  def run(background = T.unsafe(nil), thread_name: T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#202
  def running; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#614
  def shutting_down?; end

  # Returns a hash of stats about the running server for reporting purposes.
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/server.rb#625
  def stats; end

  # Stops the acceptor thread and then causes the worker threads to finish
  # off the request queue before finally exiting.
  #
  # source://puma//lib/puma/server.rb#599
  def stop(sync = T.unsafe(nil)); end

  # Returns the value of attribute thread.
  #
  # source://puma//lib/puma/server.rb#38
  def thread; end

  # source://puma//lib/puma/server.rb#167
  def uncork_socket(socket); end

  # Triggers a client timeout if the thread-pool shuts down
  # during execution of the provided block.
  #
  # source://puma//lib/puma/server.rb#500
  def with_force_shutdown(client, &block); end

  private

  # source://puma//lib/puma/server.rb#581
  def notify_safely(message); end

  class << self
    # source://puma//lib/puma/server.rb#119
    def current; end

    private

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/server.rb#131
    def closed_socket_supported?; end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/server.rb#125
    def tcp_cork_supported?; end
  end
end

# List of methods invoked by #stats.
#
# @version 5.0.0
#
# source://puma//lib/puma/server.rb#620
Puma::Server::STAT_METHODS = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/server.rb#60
Puma::Server::ThreadLocalKey = T.let(T.unsafe(nil), Symbol)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when no puma "workers" are needed
# i.e. only using "threaded" mode. For example `$ puma -t 1:5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
class Puma::Single < ::Puma::Runner
  # source://puma//lib/puma/single.rb#31
  def halt; end

  # source://puma//lib/puma/single.rb#23
  def restart; end

  # source://puma//lib/puma/single.rb#41
  def run; end

  # source://puma//lib/puma/single.rb#17
  def stats; end

  # source://puma//lib/puma/single.rb#27
  def stop; end

  # source://puma//lib/puma/single.rb#35
  def stop_blocked; end
end

# Internal Docs for A simple thread pool management object.
#
# Each Puma "worker" has a thread pool to process requests.
#
# First a connection to a client is made in `Puma::Server`. It is wrapped in a
# `Puma::Client` instance and then passed to the `Puma::Reactor` to ensure
# the whole request is buffered into memory. Once the request is ready, it is passed into
# a thread pool via the `Puma::ThreadPool#<<` operator where it is stored in a `@todo` array.
#
# Each thread in the pool has an internal loop where it pulls a request from the `@todo` array
# and processes it.
class Puma::ThreadPool
  # Maintain a minimum of +min+ and maximum of +max+ threads
  # in the pool.
  #
  # The block passed is the work that will be performed in each
  # thread.
  #
  # @return [ThreadPool] a new instance of ThreadPool
  #
  # source://puma//lib/puma/thread_pool.rb#32
  def initialize(name, min, max, *extra, &block); end

  # Add +work+ to the todo list for a Thread to pickup and process.
  #
  # source://puma//lib/puma/thread_pool.rb#185
  def <<(work); end

  # source://puma//lib/puma/thread_pool.rb#327
  def auto_reap!(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#322
  def auto_trim!(timeout = T.unsafe(nil)); end

  # How many objects have yet to be processed by the pool?
  #
  # source://puma//lib/puma/thread_pool.rb#82
  def backlog; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#93
  def busy_threads; end

  # Returns the value of attribute clean_thread_locals.
  #
  # source://puma//lib/puma/thread_pool.rb#71
  def clean_thread_locals; end

  # Sets the attribute clean_thread_locals
  #
  # @param value the value to set the attribute clean_thread_locals to.
  #
  # source://puma//lib/puma/thread_pool.rb#71
  def clean_thread_locals=(_arg0); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#72
  def out_of_band_hook; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#72
  def out_of_band_hook=(_arg0); end

  # source://puma//lib/puma/thread_pool.rb#87
  def pool_capacity; end

  # If there are dead threads in the pool make them go away while decreasing
  # spawned counter so that new healthy threads could be created again.
  #
  # source://puma//lib/puma/thread_pool.rb#280
  def reap; end

  # Tell all threads in the pool to exit and wait for them to finish.
  # Wait +timeout+ seconds then raise +ForceShutdown+ in remaining threads.
  # Next, wait an extra +grace+ seconds then force-kill remaining threads.
  # Finally, wait +kill_grace+ seconds for remaining threads to exit.
  #
  # source://puma//lib/puma/thread_pool.rb#350
  def shutdown(timeout = T.unsafe(nil)); end

  # Returns the value of attribute spawned.
  #
  # source://puma//lib/puma/thread_pool.rb#70
  def spawned; end

  # If there are any free threads in the pool, tell one to go ahead
  # and exit. If +force+ is true, then a trim request is requested
  # even if all threads are being utilized.
  #
  # source://puma//lib/puma/thread_pool.rb#268
  def trim(force = T.unsafe(nil)); end

  # Returns the value of attribute trim_requested.
  #
  # source://puma//lib/puma/thread_pool.rb#70
  def trim_requested; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#244
  def wait_for_less_busy_worker(delay_s); end

  # This method is used by `Puma::Server` to let the server know when
  # the thread pool can pull more requests from the socket and
  # pass to the reactor.
  #
  # The general idea is that the thread pool can only work on a fixed
  # number of requests at the same time. If it is already processing that
  # number of requests then it is at capacity. If another Puma process has
  # spare capacity, then the request can be left on the socket so the other
  # worker can pick it up and process it.
  #
  # For example: if there are 5 threads, but only 4 working on
  # requests, this method will not wait and the `Puma::Server`
  # can pull a request right away.
  #
  # If there are 5 threads and all 5 of them are busy, then it will
  # pause here, and wait until the `not_full` condition variable is
  # signaled, usually this indicates that a request has been processed.
  #
  # It's important to note that even though the server might accept another
  # request, it might not be added to the `@todo` array right away.
  # For example if a slow client has only sent a header, but not a body
  # then the `@todo` array would stay the same size as the reactor works
  # to try to buffer the request. In that scenario the next call to this
  # method would not block and another request would be added into the reactor
  # by the server. This would continue until a fully buffered request
  # makes it through the reactor and can then be processed by the thread pool.
  #
  # source://puma//lib/puma/thread_pool.rb#227
  def wait_until_not_full; end

  # Returns the value of attribute waiting.
  #
  # source://puma//lib/puma/thread_pool.rb#70
  def waiting; end

  # Allows ThreadPool::ForceShutdown to be raised within the
  # provided block if the thread is forced to shutdown during execution.
  #
  # source://puma//lib/puma/thread_pool.rb#334
  def with_force_shutdown; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#178
  def with_mutex(&block); end

  private

  #
  # Must be called with @mutex held!
  #
  # source://puma//lib/puma/thread_pool.rb#101
  def spawn_thread; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#162
  def trigger_out_of_band_hook; end

  class << self
    # source://puma//lib/puma/thread_pool.rb#74
    def clean_thread_locals; end
  end
end

class Puma::ThreadPool::Automaton
  # @return [Automaton] a new instance of Automaton
  #
  # source://puma//lib/puma/thread_pool.rb#296
  def initialize(pool, timeout, thread_name, message); end

  # source://puma//lib/puma/thread_pool.rb#304
  def start!; end

  # source://puma//lib/puma/thread_pool.rb#316
  def stop; end
end

class Puma::ThreadPool::ForceShutdown < ::RuntimeError; end

# How long, after raising the ForceShutdown of a thread during
# forced shutdown mode, to wait for the thread to try and finish
# up its work before leaving the thread to die on the vine.
#
# source://puma//lib/puma/thread_pool.rb#24
Puma::ThreadPool::SHUTDOWN_GRACE_TIME = T.let(T.unsafe(nil), Integer)

class Puma::UnknownPlugin < ::RuntimeError; end
class Puma::UnsupportedBackend < ::StandardError; end
class Puma::UnsupportedOption < ::RuntimeError; end

# A class used for storing "leveled" configuration options.
#
# In this class any "user" specified options take precedence over any
# "file" specified options, take precedence over any "default" options.
#
# User input is preferred over "defaults":
#   user_options    = { foo: "bar" }
#   default_options = { foo: "zoo" }
#   options = UserFileDefaultOptions.new(user_options, default_options)
#   puts options[:foo]
#   # => "bar"
#
# All values can be accessed via `all_of`
#
#   puts options.all_of(:foo)
#   # => ["bar", "zoo"]
#
# A "file" option can be set. This config will be preferred over "default" options
# but will defer to any available "user" specified options.
#
#   user_options    = { foo: "bar" }
#   default_options = { rackup: "zoo.rb" }
#   options = UserFileDefaultOptions.new(user_options, default_options)
#   options.file_options[:rackup] = "sup.rb"
#   puts options[:rackup]
#   # => "sup.rb"
#
# The "default" options can be set via procs. These are resolved during runtime
# via calls to `finalize_values`
class Puma::UserFileDefaultOptions
  # @return [UserFileDefaultOptions] a new instance of UserFileDefaultOptions
  #
  # source://puma//lib/puma/configuration.rb#49
  def initialize(user_options, default_options); end

  # source://puma//lib/puma/configuration.rb#57
  def [](key); end

  # source://puma//lib/puma/configuration.rb#61
  def []=(key, value); end

  # source://puma//lib/puma/configuration.rb#73
  def all_of(key); end

  # Returns the value of attribute default_options.
  #
  # source://puma//lib/puma/configuration.rb#55
  def default_options; end

  # source://puma//lib/puma/configuration.rb#65
  def fetch(key, default_value = T.unsafe(nil)); end

  # Returns the value of attribute file_options.
  #
  # source://puma//lib/puma/configuration.rb#55
  def file_options; end

  # source://puma//lib/puma/configuration.rb#97
  def final_options; end

  # source://puma//lib/puma/configuration.rb#89
  def finalize_values; end

  # Returns the value of attribute user_options.
  #
  # source://puma//lib/puma/configuration.rb#55
  def user_options; end
end

module Puma::Util
  private

  # source://puma//lib/puma/util.rb#24
  def escape(s, encoding = T.unsafe(nil)); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/util.rb#43
  def nakayoshi_gc(events); end

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'
  # and ';' characters.  You can also use this to parse
  # cookies by changing the characters used in the second
  # parameter (which defaults to '&;').
  #
  # source://puma//lib/puma/util.rb#60
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://puma//lib/puma/util.rb#9
  def pipe; end

  # An instance method on Thread has been provided to address https://bugs.ruby-lang.org/issues/13632,
  # which currently effects some older versions of Ruby: 2.2.7 2.2.8 2.2.9 2.2.10 2.3.4 2.4.1
  # Additional context: https://github.com/puma/puma/pull/1345
  #
  # source://puma//lib/puma/util.rb#16
  def purge_interrupt_queue; end

  # source://puma//lib/puma/util.rb#28
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    # source://puma//lib/puma/util.rb#24
    def escape(s, encoding = T.unsafe(nil)); end

    # @version 5.0.0
    #
    # source://puma//lib/puma/util.rb#43
    def nakayoshi_gc(events); end

    # Stolen from Mongrel, with some small modifications:
    # Parses a query string by breaking it up at the '&'
    # and ';' characters.  You can also use this to parse
    # cookies by changing the characters used in the second
    # parameter (which defaults to '&;').
    #
    # source://puma//lib/puma/util.rb#60
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://puma//lib/puma/util.rb#9
    def pipe; end

    # An instance method on Thread has been provided to address https://bugs.ruby-lang.org/issues/13632,
    # which currently effects some older versions of Ruby: 2.2.7 2.2.8 2.2.9 2.2.10 2.3.4 2.4.1
    # Additional context: https://github.com/puma/puma/pull/1345
    #
    # source://puma//lib/puma/util.rb#16
    def purge_interrupt_queue; end

    # source://puma//lib/puma/util.rb#28
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/util.rb#53
Puma::Util::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# A case-insensitive Hash that preserves the original case of a
# header when set.
class Puma::Util::HeaderHash < ::Hash
  # @return [HeaderHash] a new instance of HeaderHash
  #
  # source://puma//lib/puma/util.rb#90
  def initialize(hash = T.unsafe(nil)); end

  # source://puma//lib/puma/util.rb#109
  def [](k); end

  # source://puma//lib/puma/util.rb#113
  def []=(k, v); end

  # source://puma//lib/puma/util.rb#120
  def delete(k); end

  # source://puma//lib/puma/util.rb#96
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#127
  def has_key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#127
  def include?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#127
  def key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#127
  def member?(k); end

  # source://puma//lib/puma/util.rb#140
  def merge(other); end

  # source://puma//lib/puma/util.rb#135
  def merge!(other); end

  # source://puma//lib/puma/util.rb#145
  def replace(other); end

  # source://puma//lib/puma/util.rb#103
  def to_hash; end

  class << self
    # source://puma//lib/puma/util.rb#86
    def new(hash = T.unsafe(nil)); end
  end
end

module Rack
  class << self
    # source://rack/2.2.4/lib/rack/version.rb#26
    def release; end

    # source://rack/2.2.4/lib/rack/version.rb#19
    def version; end
  end
end

module Rack::Auth; end

class Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#13
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#11
  def realm; end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#11
  def realm=(_arg0); end

  private

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#29
  def bad_request; end

  # source://rack/2.2.4/lib/rack/auth/abstract/handler.rb#20
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#7
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#31
  def params; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#23
  def parts; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#15
  def provided?; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#11
  def request; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#27
  def scheme; end

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#19
  def valid?; end

  private

  # source://rack/2.2.4/lib/rack/auth/abstract/request.rb#40
  def authorization_key; end
end

# source://rack/2.2.4/lib/rack/auth/abstract/request.rb#38
Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/basic.rb#18
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/auth/basic.rb#37
  def challenge; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#41
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/basic.rb#46
  def basic?; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#50
  def credentials; end

  # source://rack/2.2.4/lib/rack/auth/basic.rb#54
  def username; end
end

module Rack::Auth::Digest; end

class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#26
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#39
  def call(env); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#22
  def opaque; end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#22
  def opaque=(_arg0); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#24
  def passwords_hashed=(_arg0); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#35
  def passwords_hashed?; end

  private

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#114
  def A1(auth, password); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#118
  def A2(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#104
  def H(data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#110
  def KD(secret, data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#79
  def challenge(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#122
  def digest(auth, password); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#104
  def md5(data); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#68
  def params(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#83
  def valid?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#99
  def valid_digest?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#95
  def valid_nonce?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#91
  def valid_opaque?(auth); end

  # source://rack/2.2.4/lib/rack/auth/digest/md5.rb#87
  def valid_qop?(auth); end
end

# source://rack/2.2.4/lib/rack/auth/digest/md5.rb#66
Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

class Rack::Auth::Digest::Nonce
  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#27
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#35
  def digest; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#47
  def fresh?; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#43
  def stale?; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#31
  def to_s; end

  # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#39
  def valid?; end

  class << self
    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#23
    def parse(string); end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def private_key; end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def private_key=(_arg0); end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def time_limit; end

    # source://rack/2.2.4/lib/rack/auth/digest/nonce.rb#20
    def time_limit=(_arg0); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#25
  def initialize; end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#31
  def [](k); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#35
  def []=(k, v); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#47
  def quote(str); end

  # source://rack/2.2.4/lib/rack/auth/digest/params.rb#41
  def to_s; end

  class << self
    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#15
    def dequote(str); end

    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#8
    def parse(str); end

    # source://rack/2.2.4/lib/rack/auth/digest/params.rb#21
    def split_header_value(str); end
  end
end

# source://rack/2.2.4/lib/rack/auth/digest/params.rb#39
Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#19
  def correct_uri?; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#15
  def digest?; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#11
  def method; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#35
  def method_missing(sym, *args); end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#23
  def nonce; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#27
  def params; end

  # source://rack/2.2.4/lib/rack/auth/digest/request.rb#31
  def respond_to?(sym, *_arg1); end
end

class Rack::BodyProxy
  # source://rack/2.2.4/lib/rack/body_proxy.rb#10
  def initialize(body, &block); end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#23
  def close; end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#35
  def closed?; end

  # source://rack/2.2.4/lib/rack/body_proxy.rb#40
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # source://rack/2.2.4/lib/rack/body_proxy.rb#17
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

class Rack::Builder
  # source://rack/2.2.4/lib/rack/builder.rb#123
  def initialize(default_app = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#243
  def call(env); end

  # source://rack/2.2.4/lib/rack/builder.rb#226
  def freeze_app; end

  # source://rack/2.2.4/lib/rack/builder.rb#219
  def map(path, &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#176
  def run(app); end

  # source://rack/2.2.4/lib/rack/builder.rb#231
  def to_app; end

  # source://rack/2.2.4/lib/rack/builder.rb#153
  def use(middleware, *args, **_arg2, &block); end

  # source://rack/2.2.4/lib/rack/builder.rb#190
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # source://rack/2.2.4/lib/rack/builder.rb#251
  def generate_map(default_app, mapping); end

  class << self
    # source://rack/2.2.4/lib/rack/builder.rb#130
    def app(default_app = T.unsafe(nil), &block); end

    # source://rack/2.2.4/lib/rack/builder.rb#93
    def load_file(path, opts = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/builder.rb#112
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/builder.rb#64
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/builder.rb#36
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#29
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#31
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#32
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

class Rack::Cascade
  # source://rack/2.2.4/lib/rack/cascade.rb#22
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/cascade.rb#57
  def <<(app); end

  # source://rack/2.2.4/lib/rack/cascade.rb#57
  def add(app); end

  # source://rack/2.2.4/lib/rack/cascade.rb#14
  def apps; end

  # source://rack/2.2.4/lib/rack/cascade.rb#33
  def call(env); end

  # source://rack/2.2.4/lib/rack/cascade.rb#62
  def include?(app); end
end

# source://rack/2.2.4/lib/rack/cascade.rb#11
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

class Rack::Chunked
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/chunked.rb#78
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/chunked.rb#97
  def call(env); end

  # source://rack/2.2.4/lib/rack/chunked.rb#83
  def chunkable_version?(ver); end
end

class Rack::Chunked::Body
  # source://rack/2.2.4/lib/rack/chunked.rb#30
  def initialize(body); end

  # source://rack/2.2.4/lib/rack/chunked.rb#50
  def close; end

  # source://rack/2.2.4/lib/rack/chunked.rb#36
  def each(&block); end

  private

  # source://rack/2.2.4/lib/rack/chunked.rb#57
  def yield_trailers; end
end

# source://rack/2.2.4/lib/rack/chunked.rb#27
Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/chunked.rb#26
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # source://rack/2.2.4/lib/rack/chunked.rb#71
  def yield_trailers; end
end

class Rack::CommonLogger
  # source://rack/2.2.4/lib/rack/common_logger.rb#24
  def initialize(app, logger = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/common_logger.rb#36
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/common_logger.rb#78
  def extract_content_length(headers); end

  # source://rack/2.2.4/lib/rack/common_logger.rb#47
  def log(env, status, header, began_at); end
end

# source://rack/2.2.4/lib/rack/common_logger.rb#18
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

class Rack::ConditionalGet
  # source://rack/2.2.4/lib/rack/conditional_get.rb#18
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#24
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/conditional_get.rb#59
  def etag_matches?(none_match, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#48
  def fresh?(env, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#65
  def modified_since?(modified_since, headers); end

  # source://rack/2.2.4/lib/rack/conditional_get.rb#72
  def to_rfc2822(since); end
end

class Rack::Config
  # source://rack/2.2.4/lib/rack/config.rb#12
  def initialize(app, &block); end

  # source://rack/2.2.4/lib/rack/config.rb#17
  def call(env); end
end

class Rack::ContentLength
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/content_length.rb#12
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/content_length.rb#16
  def call(env); end
end

class Rack::ContentType
  include ::Rack::Utils

  # source://rack/2.2.4/lib/rack/content_type.rb#15
  def initialize(app, content_type = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/content_type.rb#19
  def call(env); end
end

# source://rack/2.2.4/lib/rack.rb#43
Rack::DELETE = T.let(T.unsafe(nil), String)

class Rack::Deflater
  # source://rack/2.2.4/lib/rack/deflater.rb#36
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/deflater.rb#43
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/deflater.rb#122
  def should_deflate?(env, status, headers, body); end
end

class Rack::Deflater::GzipStream
  # source://rack/2.2.4/lib/rack/deflater.rb#85
  def initialize(body, mtime, sync); end

  # source://rack/2.2.4/lib/rack/deflater.rb#114
  def close; end

  # source://rack/2.2.4/lib/rack/deflater.rb#92
  def each(&block); end

  # source://rack/2.2.4/lib/rack/deflater.rb#109
  def write(data); end
end

class Rack::Directory
  # source://rack/2.2.4/lib/rack/directory.rb#77
  def initialize(root, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/directory.rb#83
  def call(env); end

  # source://rack/2.2.4/lib/rack/directory.rb#103
  def check_bad_request(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#113
  def check_forbidden(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#175
  def entity_not_found(path_info); end

  # source://rack/2.2.4/lib/rack/directory.rb#191
  def filesize_format(int); end

  # source://rack/2.2.4/lib/rack/directory.rb#90
  def get(env); end

  # source://rack/2.2.4/lib/rack/directory.rb#124
  def list_directory(path_info, path, script_name); end

  # source://rack/2.2.4/lib/rack/directory.rb#165
  def list_path(env, path, path_info, script_name); end

  # source://rack/2.2.4/lib/rack/directory.rb#74
  def root; end

  # source://rack/2.2.4/lib/rack/directory.rb#157
  def stat(path); end
end

# source://rack/2.2.4/lib/rack/directory.rb#14
Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/directory.rb#37
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/directory.rb#15
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

class Rack::Directory::DirectoryBody < ::Struct
  # source://rack/2.2.4/lib/rack/directory.rb#47
  def each; end

  private

  # source://rack/2.2.4/lib/rack/directory.rb#67
  def DIR_FILE_escape(htmls); end
end

# source://rack/2.2.4/lib/rack/directory.rb#183
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack.rb#36
Rack::ETAG = T.let(T.unsafe(nil), String)

class Rack::ETag
  # source://rack/2.2.4/lib/rack/etag.rb#20
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/etag.rb#26
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/etag.rb#65
  def digest_body(body); end

  # source://rack/2.2.4/lib/rack/etag.rb#57
  def etag_body?(body); end

  # source://rack/2.2.4/lib/rack/etag.rb#53
  def etag_status?(status); end

  # source://rack/2.2.4/lib/rack/etag.rb#61
  def skip_caching?(headers); end
end

# source://rack/2.2.4/lib/rack/etag.rb#18
Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/etag.rb#17
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#30
Rack::EXPIRES = T.let(T.unsafe(nil), String)

class Rack::Events
  # source://rack/2.2.4/lib/rack/events.rb#102
  def initialize(app, handlers); end

  # source://rack/2.2.4/lib/rack/events.rb#107
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/events.rb#145
  def make_request(env); end

  # source://rack/2.2.4/lib/rack/events.rb#149
  def make_response(status, headers, body); end

  # source://rack/2.2.4/lib/rack/events.rb#133
  def on_commit(request, response); end

  # source://rack/2.2.4/lib/rack/events.rb#129
  def on_error(request, response, e); end

  # source://rack/2.2.4/lib/rack/events.rb#141
  def on_finish(request, response); end

  # source://rack/2.2.4/lib/rack/events.rb#137
  def on_start(request, response); end
end

module Rack::Events::Abstract
  # source://rack/2.2.4/lib/rack/events.rb#62
  def on_commit(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#71
  def on_error(req, res, e); end

  # source://rack/2.2.4/lib/rack/events.rb#68
  def on_finish(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#65
  def on_send(req, res); end

  # source://rack/2.2.4/lib/rack/events.rb#59
  def on_start(req, res); end
end

class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # source://rack/2.2.4/lib/rack/events.rb#94
  def initialize(status, headers, body); end

  # source://rack/2.2.4/lib/rack/events.rb#92
  def body; end

  # source://rack/2.2.4/lib/rack/events.rb#99
  def to_a; end
end

class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # source://rack/2.2.4/lib/rack/events.rb#78
  def initialize(body, request, response, handlers, &block); end

  # source://rack/2.2.4/lib/rack/events.rb#85
  def each; end

  # source://rack/2.2.4/lib/rack/events.rb#76
  def request; end

  # source://rack/2.2.4/lib/rack/events.rb#76
  def response; end
end

# source://rack/2.2.4/lib/rack/file.rb#6
Rack::File = Rack::Files

class Rack::Files
  # source://rack/2.2.4/lib/rack/files.rb#29
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/files.rb#36
  def call(env); end

  # source://rack/2.2.4/lib/rack/files.rb#41
  def get(env); end

  # source://rack/2.2.4/lib/rack/files.rb#27
  def root; end

  # source://rack/2.2.4/lib/rack/files.rb#70
  def serving(request, path); end

  private

  # source://rack/2.2.4/lib/rack/files.rb#192
  def fail(status, body, headers = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/files.rb#211
  def filesize(path); end

  # source://rack/2.2.4/lib/rack/files.rb#207
  def mime_type(path, default_mime); end

  class << self
    # source://rack/2.2.4/lib/rack/files.rb#20
    def method_added(name); end
  end
end

# source://rack/2.2.4/lib/rack/files.rb#15
Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/files.rb#16
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

class Rack::Files::BaseIterator
  # source://rack/2.2.4/lib/rack/files.rb#126
  def initialize(path, ranges, options); end

  # source://rack/2.2.4/lib/rack/files.rb#146
  def bytesize; end

  # source://rack/2.2.4/lib/rack/files.rb#155
  def close; end

  # source://rack/2.2.4/lib/rack/files.rb#132
  def each; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def options; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def path; end

  # source://rack/2.2.4/lib/rack/files.rb#124
  def ranges; end

  private

  # source://rack/2.2.4/lib/rack/files.rb#173
  def each_range_part(file, range); end

  # source://rack/2.2.4/lib/rack/files.rb#159
  def multipart?; end

  # source://rack/2.2.4/lib/rack/files.rb#163
  def multipart_heading(range); end
end

class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  # source://rack/2.2.4/lib/rack/files.rb#124
  def to_path; end
end

# source://rack/2.2.4/lib/rack/files.rb#17
Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

class Rack::ForwardRequest < ::Exception
  # source://rack/2.2.4/lib/rack/recursive.rb#15
  def initialize(url, env = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/recursive.rb#13
  def env; end

  # source://rack/2.2.4/lib/rack/recursive.rb#13
  def url; end
end

# source://rack/2.2.4/lib/rack.rb#39
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#44
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#20
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#35
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#17
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#18
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#19
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

module Rack::Handler
  class << self
    # source://rack/2.2.4/lib/rack/handler.rb#51
    def default; end

    # source://rack/2.2.4/lib/rack/handler.rb#13
    def get(server); end

    # source://rack/2.2.4/lib/rack/handler.rb#36
    def pick(server_names); end

    # source://rack/2.2.4/lib/rack/handler.rb#85
    def register(server, klass); end

    # source://rack/2.2.4/lib/rack/handler.rb#75
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::CGI
  class << self
    # source://rack/2.2.4/lib/rack/handler/cgi.rb#6
    def run(app, **options); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#51
    def send_body(body); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#40
    def send_headers(status, headers); end

    # source://rack/2.2.4/lib/rack/handler/cgi.rb#11
    def serve(app); end
  end
end

class Rack::Handler::WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  # source://rack/2.2.4/lib/rack/handler/webrick.rb#61
  def initialize(server, app); end

  # source://rack/2.2.4/lib/rack/handler/webrick.rb#66
  def service(req, res); end

  class << self
    # source://rack/2.2.4/lib/rack/handler/webrick.rb#26
    def run(app, **options); end

    # source://rack/2.2.4/lib/rack/handler/webrick.rb#54
    def shutdown; end

    # source://rack/2.2.4/lib/rack/handler/webrick.rb#44
    def valid_options; end
  end
end

class Rack::Head
  # source://rack/2.2.4/lib/rack/head.rb#7
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/head.rb#11
  def call(env); end
end

# source://rack/2.2.4/lib/rack.rb#46
Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::Lint
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#10
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/lint.rb#41
  def _call(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#37
  def call(env = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/lint.rb#719
  def check_content_length(status, headers); end

  # source://rack/2.2.4/lib/rack/lint.rb#705
  def check_content_type(status, headers); end

  # source://rack/2.2.4/lib/rack/lint.rb#77
  def check_env(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#497
  def check_error(error); end

  # source://rack/2.2.4/lib/rack/lint.rb#668
  def check_headers(header); end

  # source://rack/2.2.4/lib/rack/lint.rb#562
  def check_hijack(env); end

  # source://rack/2.2.4/lib/rack/lint.rb#609
  def check_hijack_response(headers, env); end

  # source://rack/2.2.4/lib/rack/lint.rb#377
  def check_input(input); end

  # source://rack/2.2.4/lib/rack/lint.rb#661
  def check_status(status); end

  # source://rack/2.2.4/lib/rack/lint.rb#792
  def close; end

  # source://rack/2.2.4/lib/rack/lint.rb#745
  def each; end

  # source://rack/2.2.4/lib/rack/lint.rb#732
  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  # source://rack/2.2.4/lib/rack/lint.rb#19
  def assert(message); end
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#509
  def initialize(error); end

  # source://rack/2.2.4/lib/rack/lint.rb#531
  def close(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#526
  def flush; end

  # source://rack/2.2.4/lib/rack/lint.rb#514
  def puts(str); end

  # source://rack/2.2.4/lib/rack/lint.rb#519
  def write(str); end
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  extend ::Forwardable

  # source://rack/2.2.4/lib/rack/lint.rb#547
  def initialize(io); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def closed?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flush(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read_nonblock(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write_nonblock(*args, **_arg1, &block); end
end

# source://rack/2.2.4/lib/rack/lint.rb#540
Rack::Lint::HijackWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.4/lib/rack/lint.rb#398
  def initialize(input); end

  # source://rack/2.2.4/lib/rack/lint.rb#491
  def close(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#463
  def each(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#404
  def gets(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#430
  def read(*args); end

  # source://rack/2.2.4/lib/rack/lint.rb#478
  def rewind(*args); end
end

class Rack::Lint::LintError < ::RuntimeError; end

class Rack::Lock
  # source://rack/2.2.4/lib/rack/lock.rb#9
  def initialize(app, mutex = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/lock.rb#13
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/lock.rb#27
  def unlock; end
end

class Rack::Logger
  # source://rack/2.2.4/lib/rack/logger.rb#8
  def initialize(app, level = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/logger.rb#12
  def call(env); end
end

class Rack::MediaType
  class << self
    # source://rack/2.2.4/lib/rack/media_type.rb#26
    def params(content_type); end

    # source://rack/2.2.4/lib/rack/media_type.rb#16
    def type(content_type); end

    private

    # source://rack/2.2.4/lib/rack/media_type.rb#38
    def strip_doublequotes(str); end
  end
end

# source://rack/2.2.4/lib/rack/media_type.rb#7
Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rack::MethodOverride
  # source://rack/2.2.4/lib/rack/method_override.rb#11
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/method_override.rb#15
  def call(env); end

  # source://rack/2.2.4/lib/rack/method_override.rb#27
  def method_override(env); end

  private

  # source://rack/2.2.4/lib/rack/method_override.rb#40
  def allowed_methods; end

  # source://rack/2.2.4/lib/rack/method_override.rb#44
  def method_override_param(req); end
end

# source://rack/2.2.4/lib/rack/method_override.rb#9
Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/method_override.rb#5
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/method_override.rb#8
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/method_override.rb#7
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime
  private

  # source://rack/2.2.4/lib/rack/mime.rb#30
  def match?(value, matcher); end

  # source://rack/2.2.4/lib/rack/mime.rb#18
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.4/lib/rack/mime.rb#30
    def match?(value, matcher); end

    # source://rack/2.2.4/lib/rack/mime.rb#18
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/mime.rb#51
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

class Rack::MiniProfiler
  extend ::Rack::MiniProfiler::ProfilingMethods

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#115
  def initialize(app, config = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#206
  def advanced_debugging_enabled?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#575
  def analyze_memory; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#792
  def cache_control_value; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#214
  def call(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#788
  def cancel_auto_inject(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#202
  def config; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#194
  def current; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#198
  def current=(c); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#547
  def dump_env(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#529
  def dump_exceptions(exceptions); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#682
  def flamegraph(graph, path); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#167
  def generate_html(page_struct, env, result_json = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#730
  def get_profile_script(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#651
  def help(client_settings, env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#711
  def ids(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#720
  def ids_comma_separated(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#508
  def inject(fragment, script); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#474
  def inject_profiler(env, status, headers, body); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#646
  def make_link(postfix, env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#179
  def serve_html(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#130
  def serve_results(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#641
  def text_result(body); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#210
  def tool_disabled_message(client_settings); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#569
  def trim_strings(strings, max_size); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#126
  def user(env); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#798
  def handle_snapshots_request(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#863
  def rails_route_from_path(path, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#845
  def serve_flamegraph(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#890
  def take_snapshot(env, start); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#884
  def take_snapshot?(path); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#879
  def url_for_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#874
  def url_for_snapshots_group(group_name); end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#48
    def add_snapshot_custom_field(key, value); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#84
    def advanced_tools_message; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#72
    def authorize_request; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#90
    def binds_to_params(binds); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#25
    def config; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#63
    def create_current(env = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#37
    def current; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#41
    def current=(c); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#76
    def deauthorize_request; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#59
    def discard_results; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#16
    def generate_id; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#54
    def get_snapshot_custom_fields; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#12
    def patch_rails?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#106
    def redact_sql_queries?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#80
    def request_authorized?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#20
    def reset_config; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#29
    def resources_root; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#33
    def share_template; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#101
    def snapshots_transporter?; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#10
    def subscribe_sql_active_record; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiler.rb#10
    def subscribe_sql_active_record=(_arg0); end
  end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/asset_version.rb#4
Rack::MiniProfiler::ASSET_VERSION = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#40
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#34
  def diagnostics(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#63
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#57
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#30
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#14
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#67
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#48
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#10
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#26
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#18
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#22
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#44
  def should_take_snapshot?(period); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#79
  def snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#71
  def snapshots_overview; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/abstract_store.rb#8
Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::ClientSettings
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#16
  def initialize(env, store, start); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#118
  def backtrace_default?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#114
  def backtrace_full?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#14
  def backtrace_level; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#14
  def backtrace_level=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#122
  def backtrace_none?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#13
  def disable_profiling; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#13
  def disable_profiling=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#110
  def disable_profiling?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#84
  def discard_cookie!(headers); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#42
  def handle_cookie(result); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#90
  def has_valid_cookie?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#58
  def write!(headers); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#9
Rack::MiniProfiler::ClientSettings::BACKTRACE_DEFAULT = T.let(T.unsafe(nil), T.untyped)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#10
Rack::MiniProfiler::ClientSettings::BACKTRACE_FULL = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#11
Rack::MiniProfiler::ClientSettings::BACKTRACE_NONE = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/client_settings.rb#7
Rack::MiniProfiler::ClientSettings::COOKIE_NAME = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::Config
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#93
  def assets_url; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#111
  def assets_url=(lmbda); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def authorization_mode; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#97
  def authorization_mode=(mode); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def auto_inject; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def auto_inject=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_ignores; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_ignores=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_includes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_includes=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_remove; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_remove=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_threshold_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def backtrace_threshold_ms=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def base_url_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def base_url_path=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def collapse_results; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def collapse_results=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def content_security_policy_nonce; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def content_security_policy_nonce=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def cookie_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def cookie_path=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def disable_caching; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def disable_caching=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_advanced_debugging_tools; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_advanced_debugging_tools=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_hotwire_turbo_drive_support; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enable_hotwire_turbo_drive_support=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enabled; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def enabled=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_mode; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_mode=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_sample_rate; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def flamegraph_sample_rate=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#122
  def horizontal_position; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def html_container; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def html_container=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def logger; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def logger=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshot_groups; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshot_groups=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshots_per_group; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_snapshots_per_group=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_sql_param_length; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_sql_param_length=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_traces_to_show; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def max_traces_to_show=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#126
  def merge!(config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def position; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def position=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def pre_authorize_cb; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def pre_authorize_cb=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_children; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_children=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_controls; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_controls=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_total_sql_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_total_sql_count=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_trivial; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def show_trivial=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_paths; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_paths=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_schema_queries; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_schema_queries=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_sql_param_names; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def skip_sql_param_names=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_every_n_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_every_n_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_hidden_custom_fields; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshot_hidden_custom_fields=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_redact_sql_queries; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_redact_sql_queries=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_auth_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_auth_key=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_destination_url; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_destination_url=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_gzip_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def snapshots_transport_gzip_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def start_hidden; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def start_hidden=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_failure; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_failure=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_instance; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_instance=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_options; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def storage_options=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def suppress_encoding; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def suppress_encoding=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def toggle_shortcut; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def toggle_shortcut=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def use_existing_jquery; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def use_existing_jquery=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def user_provider; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#9
  def user_provider=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#118
  def vertical_position; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#6
    def attr_accessor(*vars); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#12
    def attributes; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/config.rb#16
    def default; end
  end
end

class Rack::MiniProfiler::Context
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#7
  def initialize(opts = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def current_timer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def current_timer=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def discard; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def discard=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def full_backtrace; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def full_backtrace=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def inject_js; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def inject_js=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def measure; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def measure=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def mpt_init; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def mpt_init=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def page_struct; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def page_struct=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def skip_backtrace; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/context.rb#4
  def skip_backtrace=(_arg0); end
end

class Rack::MiniProfiler::FileStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#49
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#145
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#161
  def cleanup_cache; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#139
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#133
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#102
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#96
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#127
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#108
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#117
  def set_viewed(user, id); end
end

class Rack::MiniProfiler::FileStore::CacheCleanupThread < ::Thread; end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#47
Rack::MiniProfiler::FileStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::FileStore::FileCache
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#12
  def initialize(path, prefix); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#17
  def [](key); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#28
  def []=(key, val); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/file_store.rb#41
  def path(key); end
end

class Rack::MiniProfiler::GCProfiler
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#5
  def initialize; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#63
  def analyze_growth(ids_before, ids_after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#79
  def analyze_initial_state(ids_before); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#51
  def analyze_strings(ids_before, ids_after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#39
  def diff_object_stats(before, after); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#10
  def object_space_stats; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/gc_profiler.rb#94
  def profile_gc(app, env); end
end

class Rack::MiniProfiler::MemcacheStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#10
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#64
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#60
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#56
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#25
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#21
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#52
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#32
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#42
  def set_viewed(user, id); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#7
Rack::MiniProfiler::MemcacheStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memcache_store.rb#8
Rack::MiniProfiler::MemcacheStore::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#50
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#130
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#123
  def cleanup_cache; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#202
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#188
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#117
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#74
  def initialize_cleanup_thread(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#63
  def initialize_locks; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#91
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#213
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#156
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#85
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#111
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#97
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#104
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#144
  def should_take_snapshot?(period); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#225
  def wipe_snapshots_data; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#48
Rack::MiniProfiler::MemoryStore::CLEANUP_CYCLE = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#47
Rack::MiniProfiler::MemoryStore::CLEANUP_INTERVAL = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore::CacheCleanupThread < ::Thread
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#10
  def initialize(interval, cycle, store); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#32
  def cleanup; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#37
  def cycle_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#41
  def increment_cycle; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#18
  def should_cleanup?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#26
  def sleepy_run; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/memory_store.rb#46
Rack::MiniProfiler::MemoryStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

module Rack::MiniProfiler::ProfilingMethods
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#143
  def counter(type, duration_ms = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#64
  def counter_method(klass, method, &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#27
  def finish_step(obj); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#72
  def profile_method(klass, method, type = T.unsafe(nil), &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#124
  def profile_singleton_method(klass, method, type = T.unsafe(nil), &blk); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#7
  def record_sql(query, elapsed_ms, params = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#20
  def start_step(name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#35
  def step(name, opts = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#68
  def uncounter_method(klass, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#50
  def unprofile_method(klass, method); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#128
  def unprofile_singleton_method(klass, method); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/profiling_methods.rb#157
  def clean_method_name(method); end
end

class Rack::MiniProfiler::RedisStore < ::Rack::MiniProfiler::AbstractStore
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#13
  def initialize(args = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#87
  def allowed_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#70
  def diagnostics(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#230
  def fetch_snapshots_group(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#206
  def fetch_snapshots_overview; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#78
  def flush_tokens; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#64
  def get_unviewed_ids(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#24
  def load(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#247
  def load_snapshot(id, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#9
  def prefix; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#136
  def push_snapshot(page_struct, group_name, config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#20
  def save(page_struct); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#47
  def set_all_unviewed(user, ids); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#38
  def set_unviewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#59
  def set_viewed(user, id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#126
  def should_take_snapshot?(period); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#83
  def simulate_expire; end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#298
  def cached_redis_eval(script, script_sha, reraise: T.unsafe(nil), argv: T.unsafe(nil), keys: T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#310
  def cleanup_corrupt_snapshots(corrupt_snapshots_ids, group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#288
  def group_snapshot_hash_key(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#282
  def group_snapshot_zset_key(group_name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#267
  def prefixed_id(id); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#271
  def redis; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#278
  def snapshot_counter_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#294
  def snapshot_overview_zset_key; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#263
  def user_key(user); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#341
  def wipe_snapshots_data; end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#115
Rack::MiniProfiler::RedisStore::COUNTER_LUA = T.let(T.unsafe(nil), String)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#124
Rack::MiniProfiler::RedisStore::COUNTER_LUA_SHA = T.let(T.unsafe(nil), String)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/storage/redis_store.rb#11
Rack::MiniProfiler::RedisStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/version.rb#6
Rack::MiniProfiler::SOURCE_CODE_URI = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::SnapshotsTransporter
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#28
  def initialize(config); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#25
  def buffer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#49
  def flush_buffer; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def gzip_requests; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def gzip_requests=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def max_buffer_size; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#26
  def max_buffer_size=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#89
  def requests_interval; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#41
  def ship(snapshot); end

  private

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#95
  def backoff_delay; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#100
  def start_thread; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#15
    def failed_http_requests_count; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#12
    def successful_http_requests_count; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#19
    def transport(snapshot); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/snapshots_transporter.rb#9
    def transported_snapshots_count; end
  end
end

module Rack::MiniProfiler::TimerStruct; end

class Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#9
  def initialize(attrs = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#17
  def [](name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#21
  def []=(name, val); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#32
  def as_json(options = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#13
  def attributes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/base.rb#26
  def to_json(*a); end
end

class Rack::MiniProfiler::TimerStruct::Client < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#27
  def initialize(env = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#31
  def redirect_count; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#35
  def timings; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#39
    def init_from_form_data(env, page_struct); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#10
    def init_instrumentation; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/client.rb#19
    def instrument(name, orig); end
  end
end

class Rack::MiniProfiler::TimerStruct::Custom < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#10
  def initialize(type, duration_ms, page, parent); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#9
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/custom.rb#9
  def parent=(_arg0); end
end

class Rack::MiniProfiler::TimerStruct::Page < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#60
  def initialize(env); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#124
  def as_json(options = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#58
  def attributes; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#116
  def attributes_to_serialize; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#104
  def duration_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#108
  def duration_ms_in_sql; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#128
  def extra_json; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#100
  def name; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#112
  def root; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#120
  def to_json(*a); end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#14
    def from_hash(hash); end

    private

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#45
    def symbolize_array(array); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/page.rb#30
    def symbolize_hash(hash); end
  end
end

class Rack::MiniProfiler::TimerStruct::Request < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#16
  def initialize(name, page, parent); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#81
  def add_child(name); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#128
  def add_custom(type, elapsed_ms, page); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#104
  def add_sql(query, elapsed_ms, page, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#172
  def adjust_depth; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#69
  def children; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def children_duration; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def children_duration=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#73
  def custom_timings; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#65
  def depth; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#53
  def duration_ms; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#57
  def duration_ms_in_sql; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#90
  def move_child(child, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#145
  def move_custom(type, custom, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#115
  def move_sql(sql, destination); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#49
  def name; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def parent=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#165
  def record_time(milliseconds = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#77
  def sql_timings; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def start; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#14
  def start=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#61
  def start_ms; end

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/request.rb#8
    def createRoot(name, page); end
  end
end

class Rack::MiniProfiler::TimerStruct::Sql < ::Rack::MiniProfiler::TimerStruct::Base
  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#11
  def initialize(query, duration_ms, page, parent, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#9
  def parent; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#9
  def parent=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#52
  def report_reader_duration(elapsed_ms); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler/timer_struct/sql.rb#60
  def trim_binds(binds); end
end

# source://rack-mini-profiler/3.0.0/lib/mini_profiler/version.rb#5
Rack::MiniProfiler::VERSION = T.let(T.unsafe(nil), String)

module Rack::MiniProfilerRails
  extend ::Rack::MiniProfilerRailsMethods

  class << self
    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#121
    def create_engine; end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#142
    def get_key(payload); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#10
    def initialize!(app); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#150
    def serves_static_assets?(app); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#146
    def shorten_identifier(identifier); end

    # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie.rb#132
    def subscribe(event, &blk); end
  end
end

class Rack::MiniProfilerRails::Railtie < ::Rails::Railtie; end

module Rack::MiniProfilerRailsMethods
  extend ::Rack::MiniProfilerRailsMethods

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#54
  def get_webpacker_assets_path; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#4
  def render_notification_handler(name, finish, start, name_as_description: T.unsafe(nil)); end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#42
  def should_measure?; end

  # source://rack-mini-profiler/3.0.0/lib/mini_profiler_rails/railtie_methods.rb#47
  def should_move?(child, node); end
end

class Rack::MockRequest
  # source://rack/2.2.4/lib/rack/mock.rb#52
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/mock.rb#65
  def delete(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#57
  def get(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#67
  def head(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#69
  def options(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#63
  def patch(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#59
  def post(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#61
  def put(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#74
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.4/lib/rack/mock.rb#105
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/mock.rb#92
    def parse_uri_rfc2396(uri); end
  end
end

# source://rack/2.2.4/lib/rack/mock.rb#43
Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  # source://rack/2.2.4/lib/rack/mock.rb#35
  def flush; end

  # source://rack/2.2.4/lib/rack/mock.rb#27
  def puts(warning); end

  # source://rack/2.2.4/lib/rack/mock.rb#38
  def string; end

  # source://rack/2.2.4/lib/rack/mock.rb#31
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError; end

class Rack::MockResponse < ::Rack::Response
  # source://rack/2.2.4/lib/rack/mock.rb#184
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/mock.rb#194
  def =~(other); end

  # source://rack/2.2.4/lib/rack/mock.rb#202
  def body; end

  # source://rack/2.2.4/lib/rack/mock.rb#226
  def cookie(name); end

  # source://rack/2.2.4/lib/rack/mock.rb#179
  def cookies; end

  # source://rack/2.2.4/lib/rack/mock.rb#222
  def empty?; end

  # source://rack/2.2.4/lib/rack/mock.rb#182
  def errors; end

  # source://rack/2.2.4/lib/rack/mock.rb#182
  def errors=(_arg0); end

  # source://rack/2.2.4/lib/rack/mock.rb#198
  def match(other); end

  # source://rack/2.2.4/lib/rack/mock.rb#179
  def original_headers; end

  private

  # source://rack/2.2.4/lib/rack/mock.rb#253
  def identify_cookie_attributes(cookie_filling); end

  # source://rack/2.2.4/lib/rack/mock.rb#232
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

# source://rack-test/2.0.2/lib/rack/test.rb#413
Rack::MockSession = Rack::Test::Session

module Rack::Multipart
  class << self
    # source://rack/2.2.4/lib/rack/multipart.rb#58
    def build_multipart(params, first = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/multipart.rb#44
    def extract_multipart(req, params = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/multipart.rb#40
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

# source://rack/2.2.4/lib/rack/multipart.rb#25
Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#24
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#19
Rack::Multipart::BROKEN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#17
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#36
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#13
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#32
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#34
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#33
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#29
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#31
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#30
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#35
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::Generator
  # source://rack/2.2.4/lib/rack/multipart/generator.rb#6
  def initialize(params, first = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#14
  def dump; end

  private

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#87
  def content_for_other(file, name); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#75
  def content_for_tempfile(io, file, name); end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#50
  def flattened_params; end

  # source://rack/2.2.4/lib/rack/multipart/generator.rb#35
  def multipart?; end
end

# source://rack/2.2.4/lib/rack/multipart.rb#15
Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#14
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#21
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#22
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#20
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end

class Rack::Multipart::Parser
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#167
  def initialize(boundary, tempfile, bufsize, query_parser); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#185
  def on_read(content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#191
  def result; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#165
  def state; end

  private

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#283
  def consume_boundary; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#281
  def full_boundary; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#293
  def get_filename(head); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#229
  def handle_consume_token; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#358
  def handle_empty_content!(content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#220
  def handle_fast_forward; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#262
  def handle_mime_body; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#239
  def handle_mime_head; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#203
  def run_parser; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#330
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    # source://rack/2.2.4/lib/rack/multipart/parser.rb#63
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end

    # source://rack/2.2.4/lib/rack/multipart/parser.rb#56
    def parse_boundary(content_type); end
  end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#18
Rack::Multipart::Parser::BOUNDARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart/parser.rb#12
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Rack::Multipart::Parser::BoundedIO
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#21
  def initialize(io, content_length); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#27
  def read(size, outbuf = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#48
  def rewind; end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#328
Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#120
  def initialize(tempfile); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#126
  def each; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#146
  def on_mime_body(mime_index, content); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#150
  def on_mime_finish(mime_index); end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#130
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#155
  def check_open_files; end
end

class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#110
  def close; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#109
  def file?; end
end

class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#86
  def get_data; end
end

class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.4/lib/rack/multipart/parser.rb#115
  def close; end

  # source://rack/2.2.4/lib/rack/multipart/parser.rb#114
  def file?; end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#54
Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

class Rack::Multipart::Parser::MultipartInfo < ::Struct
  def params; end
  def params=(_); end
  def tmp_files; end
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rack/2.2.4/lib/rack/multipart/parser.rb#14
Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)

# source://rack/2.2.4/lib/rack/multipart/parser.rb#13
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/multipart.rb#28
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#27
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#37
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#26
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/multipart.rb#16
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#12
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#10
  def content_type; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#10
  def content_type=(_arg0); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#27
  def local_path; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#36
  def method_missing(method_name, *args, &block); end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#7
  def original_filename; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#27
  def path; end

  # source://rack/2.2.4/lib/rack/multipart/uploaded_file.rb#32
  def respond_to?(*args); end
end

# source://rack/2.2.4/lib/rack/multipart.rb#18
Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

class Rack::NullLogger
  # source://rack/2.2.4/lib/rack/null_logger.rb#5
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#37
  def <<(msg); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#36
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#9
  def call(env); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#35
  def close; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#27
  def datetime_format; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#32
  def datetime_format=(datetime_format); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#15
  def debug(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#21
  def debug?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#17
  def error(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#23
  def error?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#18
  def fatal(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#24
  def fatal?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#28
  def formatter; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#33
  def formatter=(formatter); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#14
  def info(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#20
  def info?; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#25
  def level; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#30
  def level=(level); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#26
  def progname; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#31
  def progname=(progname); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#29
  def sev_threshold; end

  # source://rack/2.2.4/lib/rack/null_logger.rb#34
  def sev_threshold=(sev_threshold); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#19
  def unknown(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#16
  def warn(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/null_logger.rb#22
  def warn?; end
end

# source://rack/2.2.4/lib/rack.rb#45
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#42
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#21
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#40
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#41
Rack::PUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#25
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

class Rack::QueryParser
  # source://rack/2.2.4/lib/rack/query_parser.rb#29
  def initialize(params_class, key_space_limit, param_depth_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#27
  def key_space_limit; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#128
  def make_params; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#136
  def new_depth_limit(param_depth_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#132
  def new_space_limit(key_space_limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#87
  def normalize_params(params, name, v, depth); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#27
  def param_depth_limit; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#68
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#40
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  private

  # source://rack/2.2.4/lib/rack/query_parser.rb#146
  def params_hash_has_key?(hash, key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#142
  def params_hash_type?(obj); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#158
  def unescape(s); end

  class << self
    # source://rack/2.2.4/lib/rack/query_parser.rb#23
    def make_default(key_space_limit, param_depth_limit); end
  end
end

# source://rack/2.2.4/lib/rack/query_parser.rb#8
Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/query_parser.rb#7
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

class Rack::QueryParser::Params
  # source://rack/2.2.4/lib/rack/query_parser.rb#163
  def initialize(limit); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#169
  def [](key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#173
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#179
  def key?(key); end

  # source://rack/2.2.4/lib/rack/query_parser.rb#201
  def to_h; end

  # source://rack/2.2.4/lib/rack/query_parser.rb#201
  def to_params_hash; end
end

class Rack::QueryParser::ParamsTooDeepError < ::RangeError; end

# source://rack/2.2.4/lib/rack.rb#53
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#63
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#65
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#55
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#64
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#54
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#76
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#67
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#68
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#60
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#59
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#66
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#72
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#73
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#70
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#69
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#71
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#74
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#75
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#61
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#56
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#57
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#77
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#58
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#52
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#62
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#51
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/version.rb#23
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#22
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#23
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

class Rack::Recursive
  # source://rack/2.2.4/lib/rack/recursive.rb#35
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/recursive.rb#43
  def _call(env); end

  # source://rack/2.2.4/lib/rack/recursive.rb#39
  def call(env); end

  # source://rack/2.2.4/lib/rack/recursive.rb#50
  def include(env, path); end
end

class Rack::Reloader
  # source://rack/2.2.4/lib/rack/reloader.rb#27
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/reloader.rb#38
  def call(env); end

  # source://rack/2.2.4/lib/rack/reloader.rb#52
  def reload!(stderr = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/reloader.rb#60
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  # source://rack/2.2.4/lib/rack/reloader.rb#90
  def figure_path(file, paths); end

  # source://rack/2.2.4/lib/rack/reloader.rb#71
  def rotation; end

  # source://rack/2.2.4/lib/rack/reloader.rb#105
  def safe_stat(file); end
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # source://rack/2.2.4/lib/rack/request.rb#26
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/request.rb#40
  def delete_param(k); end

  # source://rack/2.2.4/lib/rack/request.rb#31
  def params; end

  # source://rack/2.2.4/lib/rack/request.rb#31
  def query; end

  # source://rack/2.2.4/lib/rack/request.rb#35
  def update_param(k, v); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied; end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied=(_arg0); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#88
  def xhr?; end

  class << self
    # source://rack/2.2.4/lib/rack/request.rb#16
    def ip_filter; end

    # source://rack/2.2.4/lib/rack/request.rb#16
    def ip_filter=(_arg0); end
  end
end

# source://rack/2.2.4/lib/rack/request.rb#20
Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

module Rack::Request::Env
  # source://rack/2.2.4/lib/rack/request.rb#50
  def initialize(env); end

  # source://rack/2.2.4/lib/rack/request.rb#91
  def add_header(key, v); end

  # source://rack/2.2.4/lib/rack/request.rb#102
  def delete_header(name); end

  # source://rack/2.2.4/lib/rack/request.rb#73
  def each_header(&block); end

  # source://rack/2.2.4/lib/rack/request.rb#48
  def env; end

  # source://rack/2.2.4/lib/rack/request.rb#68
  def fetch_header(name, &block); end

  # source://rack/2.2.4/lib/rack/request.rb#62
  def get_header(name); end

  # source://rack/2.2.4/lib/rack/request.rb#57
  def has_header?(name); end

  # source://rack/2.2.4/lib/rack/request.rb#78
  def set_header(name, v); end

  private

  # source://rack/2.2.4/lib/rack/request.rb#106
  def initialize_copy(other); end
end

module Rack::Request::Helpers
  # source://rack/2.2.4/lib/rack/request.rb#426
  def GET; end

  # source://rack/2.2.4/lib/rack/request.rb#440
  def POST; end

  # source://rack/2.2.4/lib/rack/request.rb#532
  def [](key); end

  # source://rack/2.2.4/lib/rack/request.rb#543
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/request.rb#519
  def accept_encoding; end

  # source://rack/2.2.4/lib/rack/request.rb#523
  def accept_language; end

  # source://rack/2.2.4/lib/rack/request.rb#227
  def authority; end

  # source://rack/2.2.4/lib/rack/request.rb#502
  def base_url; end

  # source://rack/2.2.4/lib/rack/request.rb#150
  def body; end

  # source://rack/2.2.4/lib/rack/request.rb#400
  def content_charset; end

  # source://rack/2.2.4/lib/rack/request.rb#159
  def content_length; end

  # source://rack/2.2.4/lib/rack/request.rb#271
  def content_type; end

  # source://rack/2.2.4/lib/rack/request.rb#256
  def cookies; end

  # source://rack/2.2.4/lib/rack/request.rb#181
  def delete?; end

  # source://rack/2.2.4/lib/rack/request.rb#497
  def delete_param(k); end

  # source://rack/2.2.4/lib/rack/request.rb#412
  def form_data?; end

  # source://rack/2.2.4/lib/rack/request.rb#344
  def forwarded_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#330
  def forwarded_for; end

  # source://rack/2.2.4/lib/rack/request.rb#338
  def forwarded_port; end

  # source://rack/2.2.4/lib/rack/request.rb#515
  def fullpath; end

  # source://rack/2.2.4/lib/rack/request.rb#184
  def get?; end

  # source://rack/2.2.4/lib/rack/request.rb#187
  def head?; end

  # source://rack/2.2.4/lib/rack/request.rb#296
  def host; end

  # source://rack/2.2.4/lib/rack/request.rb#281
  def host_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#285
  def host_with_port(authority = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/request.rb#304
  def hostname; end

  # source://rack/2.2.4/lib/rack/request.rb#354
  def ip; end

  # source://rack/2.2.4/lib/rack/request.rb#193
  def link?; end

  # source://rack/2.2.4/lib/rack/request.rb#160
  def logger; end

  # source://rack/2.2.4/lib/rack/request.rb#383
  def media_type; end

  # source://rack/2.2.4/lib/rack/request.rb#392
  def media_type_params; end

  # source://rack/2.2.4/lib/rack/request.rb#162
  def multithread?; end

  # source://rack/2.2.4/lib/rack/request.rb#190
  def options?; end

  # source://rack/2.2.4/lib/rack/request.rb#468
  def params; end

  # source://rack/2.2.4/lib/rack/request.rb#421
  def parseable_data?; end

  # source://rack/2.2.4/lib/rack/request.rb#196
  def patch?; end

  # source://rack/2.2.4/lib/rack/request.rb#511
  def path; end

  # source://rack/2.2.4/lib/rack/request.rb#154
  def path_info; end

  # source://rack/2.2.4/lib/rack/request.rb#155
  def path_info=(s); end

  # source://rack/2.2.4/lib/rack/request.rb#308
  def port; end

  # source://rack/2.2.4/lib/rack/request.rb#199
  def post?; end

  # source://rack/2.2.4/lib/rack/request.rb#202
  def put?; end

  # source://rack/2.2.4/lib/rack/request.rb#158
  def query_string; end

  # source://rack/2.2.4/lib/rack/request.rb#165
  def referer; end

  # source://rack/2.2.4/lib/rack/request.rb#165
  def referrer; end

  # source://rack/2.2.4/lib/rack/request.rb#157
  def request_method; end

  # source://rack/2.2.4/lib/rack/request.rb#210
  def scheme; end

  # source://rack/2.2.4/lib/rack/request.rb#151
  def script_name; end

  # source://rack/2.2.4/lib/rack/request.rb#152
  def script_name=(s); end

  # source://rack/2.2.4/lib/rack/request.rb#233
  def server_authority; end

  # source://rack/2.2.4/lib/rack/request.rb#246
  def server_name; end

  # source://rack/2.2.4/lib/rack/request.rb#250
  def server_port; end

  # source://rack/2.2.4/lib/rack/request.rb#168
  def session; end

  # source://rack/2.2.4/lib/rack/request.rb#174
  def session_options; end

  # source://rack/2.2.4/lib/rack/request.rb#350
  def ssl?; end

  # source://rack/2.2.4/lib/rack/request.rb#205
  def trace?; end

  # source://rack/2.2.4/lib/rack/request.rb#527
  def trusted_proxy?(ip); end

  # source://rack/2.2.4/lib/rack/request.rb#208
  def unlink?; end

  # source://rack/2.2.4/lib/rack/request.rb#477
  def update_param(k, v); end

  # source://rack/2.2.4/lib/rack/request.rb#507
  def url; end

  # source://rack/2.2.4/lib/rack/request.rb#161
  def user_agent; end

  # source://rack/2.2.4/lib/rack/request.rb#552
  def values_at(*keys); end

  # source://rack/2.2.4/lib/rack/request.rb#276
  def xhr?; end

  private

  # source://rack/2.2.4/lib/rack/request.rb#641
  def allowed_scheme(header); end

  # source://rack/2.2.4/lib/rack/request.rb#558
  def default_session; end

  # source://rack/2.2.4/lib/rack/request.rb#645
  def extract_proto_header(header); end

  # source://rack/2.2.4/lib/rack/request.rb#636
  def forwarded_scheme; end

  # source://rack/2.2.4/lib/rack/request.rb#574
  def parse_http_accept_header(header); end

  # source://rack/2.2.4/lib/rack/request.rb#593
  def parse_multipart; end

  # source://rack/2.2.4/lib/rack/request.rb#589
  def parse_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/request.rb#585
  def query_parser; end

  # source://rack/2.2.4/lib/rack/request.rb#632
  def reject_trusted_ip_addresses(ip_addresses); end

  # source://rack/2.2.4/lib/rack/request.rb#619
  def split_authority(authority); end

  # source://rack/2.2.4/lib/rack/request.rb#597
  def split_header(value); end

  # source://rack/2.2.4/lib/rack/request.rb#561
  def wrap_ipv6(host); end
end

# source://rack/2.2.4/lib/rack/request.rb#130
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/request.rb#115
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/request.rb#133
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#136
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#145
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#142
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#139
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#148
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/request.rb#123
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/request.rb#21
Rack::Request::SCHEME_WHITELIST = T.let(T.unsafe(nil), Array)

class Rack::Response
  include ::Rack::Response::Helpers

  # source://rack/2.2.4/lib/rack/response.rb#42
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#127
  def [](key); end

  # source://rack/2.2.4/lib/rack/response.rb#128
  def []=(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def body; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def body=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#73
  def chunked?; end

  # source://rack/2.2.4/lib/rack/response.rb#118
  def close; end

  # source://rack/2.2.4/lib/rack/response.rb#129
  def delete_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#98
  def each(&callback); end

  # source://rack/2.2.4/lib/rack/response.rb#122
  def empty?; end

  # source://rack/2.2.4/lib/rack/response.rb#80
  def finish(&block); end

  # source://rack/2.2.4/lib/rack/response.rb#127
  def get_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#126
  def has_header?(key); end

  # source://rack/2.2.4/lib/rack/response.rb#27
  def header; end

  # source://rack/2.2.4/lib/rack/response.rb#27
  def headers; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def length; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def length=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#68
  def redirect(target, status = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#128
  def set_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def status; end

  # source://rack/2.2.4/lib/rack/response.rb#26
  def status=(_arg0); end

  # source://rack/2.2.4/lib/rack/response.rb#80
  def to_a(&block); end

  # source://rack/2.2.4/lib/rack/response.rb#112
  def write(chunk); end

  class << self
    # source://rack/2.2.4/lib/rack/response.rb#19
    def [](status, headers, body); end
  end
end

# source://rack/2.2.4/lib/rack/response.rb#23
Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

module Rack::Response::Helpers
  # source://rack/2.2.4/lib/rack/response.rb#145
  def accepted?; end

  # source://rack/2.2.4/lib/rack/response.rb#171
  def add_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#148
  def bad_request?; end

  # source://rack/2.2.4/lib/rack/response.rb#246
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#229
  def cache_control; end

  # source://rack/2.2.4/lib/rack/response.rb#233
  def cache_control=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#140
  def client_error?; end

  # source://rack/2.2.4/lib/rack/response.rb#199
  def content_length; end

  # source://rack/2.2.4/lib/rack/response.rb#182
  def content_type; end

  # source://rack/2.2.4/lib/rack/response.rb#187
  def content_type=(content_type); end

  # source://rack/2.2.4/lib/rack/response.rb#144
  def created?; end

  # source://rack/2.2.4/lib/rack/response.rb#217
  def delete_cookie(key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/response.rb#238
  def do_not_cache!; end

  # source://rack/2.2.4/lib/rack/response.rb#253
  def etag; end

  # source://rack/2.2.4/lib/rack/response.rb#257
  def etag=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#150
  def forbidden?; end

  # source://rack/2.2.4/lib/rack/response.rb#158
  def include?(header); end

  # source://rack/2.2.4/lib/rack/response.rb#137
  def informational?; end

  # source://rack/2.2.4/lib/rack/response.rb#135
  def invalid?; end

  # source://rack/2.2.4/lib/rack/response.rb#204
  def location; end

  # source://rack/2.2.4/lib/rack/response.rb#208
  def location=(location); end

  # source://rack/2.2.4/lib/rack/response.rb#191
  def media_type; end

  # source://rack/2.2.4/lib/rack/response.rb#195
  def media_type_params; end

  # source://rack/2.2.4/lib/rack/response.rb#152
  def method_not_allowed?; end

  # source://rack/2.2.4/lib/rack/response.rb#147
  def moved_permanently?; end

  # source://rack/2.2.4/lib/rack/response.rb#146
  def no_content?; end

  # source://rack/2.2.4/lib/rack/response.rb#151
  def not_found?; end

  # source://rack/2.2.4/lib/rack/response.rb#143
  def ok?; end

  # source://rack/2.2.4/lib/rack/response.rb#153
  def precondition_failed?; end

  # source://rack/2.2.4/lib/rack/response.rb#156
  def redirect?; end

  # source://rack/2.2.4/lib/rack/response.rb#139
  def redirection?; end

  # source://rack/2.2.4/lib/rack/response.rb#141
  def server_error?; end

  # source://rack/2.2.4/lib/rack/response.rb#212
  def set_cookie(key, value); end

  # source://rack/2.2.4/lib/rack/response.rb#221
  def set_cookie_header; end

  # source://rack/2.2.4/lib/rack/response.rb#225
  def set_cookie_header=(v); end

  # source://rack/2.2.4/lib/rack/response.rb#138
  def successful?; end

  # source://rack/2.2.4/lib/rack/response.rb#149
  def unauthorized?; end

  # source://rack/2.2.4/lib/rack/response.rb#154
  def unprocessable?; end

  protected

  # source://rack/2.2.4/lib/rack/response.rb#287
  def append(chunk); end

  # source://rack/2.2.4/lib/rack/response.rb#263
  def buffered_body!; end
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # source://rack/2.2.4/lib/rack/response.rb#307
  def initialize(status, headers); end

  # source://rack/2.2.4/lib/rack/response.rb#315
  def delete_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#313
  def get_header(key); end

  # source://rack/2.2.4/lib/rack/response.rb#312
  def has_header?(key); end

  # source://rack/2.2.4/lib/rack/response.rb#304
  def headers; end

  # source://rack/2.2.4/lib/rack/response.rb#314
  def set_header(key, v); end

  # source://rack/2.2.4/lib/rack/response.rb#305
  def status; end

  # source://rack/2.2.4/lib/rack/response.rb#305
  def status=(_arg0); end
end

# source://rack/2.2.4/lib/rack/response.rb#24
Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

class Rack::RewindableInput
  # source://rack/2.2.4/lib/rack/rewindable_input.rb#17
  def initialize(io); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#48
  def close; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#33
  def each(&block); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#23
  def gets; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#28
  def read(*args); end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#38
  def rewind; end

  private

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#90
  def filesystem_has_posix_semantics?; end

  # source://rack/2.2.4/lib/rack/rewindable_input.rb#61
  def make_rewindable; end
end

class Rack::Runtime
  # source://rack/2.2.4/lib/rack/runtime.rb#14
  def initialize(app, name = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/runtime.rb#20
  def call(env); end
end

# source://rack/2.2.4/lib/rack/runtime.rb#11
Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/runtime.rb#12
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#24
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#27
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#28
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#26
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#33
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

class Rack::Sendfile
  # source://rack/2.2.4/lib/rack/sendfile.rb#101
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/sendfile.rb#109
  def call(env); end

  private

  # source://rack/2.2.4/lib/rack/sendfile.rb#149
  def map_accel_path(env, path); end

  # source://rack/2.2.4/lib/rack/sendfile.rb#143
  def variation(env); end
end

class Rack::Server
  # source://rack/2.2.4/lib/rack/server.rb#215
  def initialize(options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/server.rb#248
  def app; end

  # source://rack/2.2.4/lib/rack/server.rb#234
  def default_options; end

  # source://rack/2.2.4/lib/rack/server.rb#282
  def middleware; end

  # source://rack/2.2.4/lib/rack/server.rb#229
  def options; end

  # source://rack/2.2.4/lib/rack/server.rb#171
  def options=(_arg0); end

  # source://rack/2.2.4/lib/rack/server.rb#330
  def server; end

  # source://rack/2.2.4/lib/rack/server.rb#286
  def start(&block); end

  private

  # source://rack/2.2.4/lib/rack/server.rb#411
  def build_app(app); end

  # source://rack/2.2.4/lib/rack/server.rb#344
  def build_app_and_options_from_config; end

  # source://rack/2.2.4/lib/rack/server.rb#392
  def build_app_from_string; end

  # source://rack/2.2.4/lib/rack/server.rb#440
  def check_pid!; end

  # source://rack/2.2.4/lib/rack/server.rb#425
  def daemonize_app; end

  # source://rack/2.2.4/lib/rack/server.rb#354
  def handle_profiling(heapfile, profile_mode, filename); end

  # source://rack/2.2.4/lib/rack/server.rb#382
  def make_profile_name(filename); end

  # source://rack/2.2.4/lib/rack/server.rb#407
  def opt_parser; end

  # source://rack/2.2.4/lib/rack/server.rb#396
  def parse_options(args); end

  # source://rack/2.2.4/lib/rack/server.rb#450
  def pidfile_process_status; end

  # source://rack/2.2.4/lib/rack/server.rb#421
  def wrapped_app; end

  # source://rack/2.2.4/lib/rack/server.rb#432
  def write_pid; end

  class << self
    # source://rack/2.2.4/lib/rack/server.rb#259
    def default_middleware_by_environment; end

    # source://rack/2.2.4/lib/rack/server.rb#253
    def logging_middleware; end

    # source://rack/2.2.4/lib/rack/server.rb#277
    def middleware; end

    # source://rack/2.2.4/lib/rack/server.rb#167
    def start(options = T.unsafe(nil)); end
  end
end

class Rack::Server::Options
  # source://rack/2.2.4/lib/rack/server.rb#127
  def handler_opts(options); end

  # source://rack/2.2.4/lib/rack/server.rb#12
  def parse!(args); end
end

module Rack::Session; end
module Rack::Session::Abstract; end

class Rack::Session::Abstract::ID < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#517
  def delete_session(req, sid, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#502
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#510
  def write_session(req, sid, session, options); end

  class << self
    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#488
    def inherited(klass); end
  end
end

class Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#250
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#259
  def call(env); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#373
  def commit_session(req, res); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#263
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def default_options; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def key; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#248
  def sid_secure; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#342
  def commit_session?(req, session, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#408
  def cookie_value(data); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#328
  def current_session_id(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#448
  def delete_session(req, sid, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#320
  def extract_session_id(request); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#433
  def find_session(env, sid); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#359
  def force_options?(options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#355
  def forced_session_update?(session, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#288
  def generate_sid(secure = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#278
  def initialize_sid; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#312
  def load_session(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#351
  def loaded_session?(session); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#274
  def make_request(env); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#301
  def prepare_session(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#363
  def security_matches?(request, options); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#424
  def session_class; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#334
  def session_exists?(req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#415
  def set_cookie(request, res, cookie); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#441
  def write_session(req, sid, session, options); end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#234
Rack::Session::Abstract::Persisted::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::PersistedSecure < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#471
  def extract_session_id(*_arg0); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#465
  def generate_sid(*_arg0); end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#482
  def cookie_value(data); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#478
  def session_class; end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < ::Rack::Session::Abstract::SessionHash
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#455
  def [](key); end
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#62
  def initialize(store, req); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#82
  def [](key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#108
  def []=(key, value); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#114
  def clear; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#140
  def delete(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#119
  def destroy; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#87
  def dig(key, *keys); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#77
  def each(&block); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#163
  def empty?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#153
  def exists?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#92
  def fetch(key, default = T.unsafe(nil), &block); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def has_key?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#68
  def id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#46
  def id=(_arg0); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def include?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#145
  def inspect; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#101
  def key?(key); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#168
  def keys; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#159
  def loaded?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#129
  def merge!(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#73
  def options; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#135
  def replace(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#108
  def store(key, value); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#124
  def to_hash; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#129
  def update(hash); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#173
  def values; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#188
  def load!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#180
  def load_for_read!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#184
  def load_for_write!; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#194
  def stringify_keys(other); end

  class << self
    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#50
    def find(req); end

    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#54
    def set(req, session); end

    # source://rack/2.2.4/lib/rack/session/abstract/id.rb#58
    def set_options(req, options); end
  end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#48
Rack::Session::Abstract::SessionHash::Unspecified = T.let(T.unsafe(nil), Object)

class Rack::Session::Cookie < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.4/lib/rack/session/cookie.rb#107
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#105
  def coder; end

  private

  # source://rack/2.2.4/lib/rack/session/cookie.rb#180
  def delete_session(req, session_id, options); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#185
  def digest_match?(data, digest); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#132
  def extract_session_id(request); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#126
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#192
  def generate_hmac(data, secret); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#149
  def persistent_session_id!(data, sid = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#196
  def secure?(options); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#136
  def unpacked_cookie_data(request); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#164
  def write_session(req, session_id, session, options); end
end

class Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#56
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#52
  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#79
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#75
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#66
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#62
  def encode(str); end
end

class Rack::Session::Cookie::Base64::ZipJSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.4/lib/rack/session/cookie.rb#90
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#86
  def encode(obj); end
end

class Rack::Session::Cookie::Identity
  # source://rack/2.2.4/lib/rack/session/cookie.rb#102
  def decode(str); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#101
  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  # source://rack/2.2.4/lib/rack/session/cookie.rb#158
  def initialize(session_id, cookie_value); end

  # source://rack/2.2.4/lib/rack/session/cookie.rb#156
  def cookie_value; end
end

class Rack::Session::Pool < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.4/lib/rack/session/pool.rb#33
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#63
  def delete_session(req, session_id, options); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#46
  def find_session(req, sid); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#39
  def generate_sid; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#30
  def mutex; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#30
  def pool; end

  # source://rack/2.2.4/lib/rack/session/pool.rb#71
  def with_lock(req); end

  # source://rack/2.2.4/lib/rack/session/pool.rb#56
  def write_session(req, session_id, new_session, options); end

  private

  # source://rack/2.2.4/lib/rack/session/pool.rb#80
  def get_session_with_fallback(sid); end
end

# source://rack/2.2.4/lib/rack/session/pool.rb#31
Rack::Session::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::SessionId
  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#20
  def initialize(public_id); end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def cookie_value; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#31
  def empty?; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#32
  def inspect; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#24
  def private_id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def public_id; end

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#18
  def to_s; end

  private

  # source://rack/2.2.4/lib/rack/session/abstract/id.rb#36
  def hash_sid(sid); end
end

# source://rack/2.2.4/lib/rack/session/abstract/id.rb#16
Rack::Session::SessionId::ID_VERSION = T.let(T.unsafe(nil), Integer)

class Rack::ShowExceptions
  # source://rack/2.2.4/lib/rack/show_exceptions.rb#18
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#22
  def call(env); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#57
  def dump_exception(exception); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#103
  def h(obj); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#48
  def prefers_plaintext?(env); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#63
  def pretty(env, exception); end

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#99
  def template; end

  private

  # source://rack/2.2.4/lib/rack/show_exceptions.rb#52
  def accepts_html?(env); end
end

# source://rack/2.2.4/lib/rack/show_exceptions.rb#16
Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)

# source://rack/2.2.4/lib/rack/show_exceptions.rb#118
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

class Rack::ShowStatus
  # source://rack/2.2.4/lib/rack/show_status.rb#14
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/show_status.rb#19
  def call(env); end

  # source://rack/2.2.4/lib/rack/show_status.rb#44
  def h(obj); end
end

# source://rack/2.2.4/lib/rack/show_status.rb#59
Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

class Rack::Static
  # source://rack/2.2.4/lib/rack/static.rb#91
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/static.rb#107
  def add_index_root?(path); end

  # source://rack/2.2.4/lib/rack/static.rb#166
  def applicable_rules(path); end

  # source://rack/2.2.4/lib/rack/static.rb#123
  def call(env); end

  # source://rack/2.2.4/lib/rack/static.rb#119
  def can_serve(path); end

  # source://rack/2.2.4/lib/rack/static.rb#111
  def overwrite_file_path(path); end

  # source://rack/2.2.4/lib/rack/static.rb#115
  def route_file(path); end
end

# source://rack/2.2.4/lib/rack.rb#48
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#34
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

class Rack::TempfileReaper
  # source://rack/2.2.4/lib/rack/tempfile_reaper.rb#9
  def initialize(app); end

  # source://rack/2.2.4/lib/rack/tempfile_reaper.rb#13
  def call(env); end
end

module Rack::Test
  class << self
    # source://rack-test/2.0.2/lib/rack/test.rb#407
    def encoding_aware_strings?; end
  end
end

class Rack::Test::Cookie
  include ::Rack::Utils

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#23
  def initialize(raw, uri = T.unsafe(nil), default_host = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#107
  def <=>(other); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#58
  def domain; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#53
  def empty?; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#85
  def expired?; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#80
  def expires; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#70
  def http_only?; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#102
  def matches?(uri); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#14
  def name; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#75
  def path; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#21
  def raw; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#48
  def replaces?(other); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#64
  def secure?; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#112
  def to_h; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#112
  def to_hash; end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#90
  def valid?(uri); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#17
  def value; end

  private

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#124
  def default_uri; end
end

class Rack::Test::CookieJar
  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#136
  def initialize(cookies = T.unsafe(nil), default_host = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#192
  def <<(new_cookie); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#143
  def [](name); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#153
  def []=(name, value); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#167
  def delete(name); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#203
  def for(uri); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#159
  def get_cookie(name); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#177
  def merge(raw_cookies, uri = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#220
  def to_hash; end

  private

  # source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#239
  def each_cookie_for(uri); end
end

# source://rack-test/2.0.2/lib/rack/test/cookie_jar.rb#134
Rack::Test::CookieJar::DELIMITER = T.let(T.unsafe(nil), String)

# source://rack-test/2.0.2/lib/rack/test.rb#33
Rack::Test::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://rack-test/2.0.2/lib/rack/test.rb#42
Rack::Test::END_BOUNDARY = T.let(T.unsafe(nil), String)

class Rack::Test::Error < ::StandardError; end

# source://rack-test/2.0.2/lib/rack/test.rb#36
Rack::Test::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

module Rack::Test::Methods
  extend ::Forwardable

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#91
  def _rack_test_current_session=(_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def authorize(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def basic_authorize(*args, **_arg1, &block); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#40
  def build_rack_test_session(_name); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def clear_cookies(*args, **_arg1, &block); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#51
  def current_session; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def custom_request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def delete(*args, **_arg1, &block); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#64
  def digest_authorize(username, password); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def env(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def follow_redirect!(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def get(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def head(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def header(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last_request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last_response(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def options(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def patch(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def post(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def put(*args, **_arg1, &block); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#29
  def rack_mock_session(name = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#29
  def rack_test_session(name = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def request(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def set_cookie(*args, **_arg1, &block); end

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#57
  def with_session(name); end

  private

  # source://rack-test/2.0.2/lib/rack/test/methods.rb#91
  def _rack_test_current_session; end
end

# source://rack-test/2.0.2/lib/rack/test.rb#39
Rack::Test::START_BOUNDARY = T.let(T.unsafe(nil), String)

class Rack::Test::Session
  include ::Rack::Utils
  include ::Rack::Test::Utils
  extend ::Forwardable

  # source://rack-test/2.0.2/lib/rack/test.rb#99
  def initialize(app, default_host = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test.rb#217
  def _digest_authorize(username, password); end

  # source://rack-test/2.0.2/lib/rack/test.rb#120
  def after_request(&block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#200
  def authorize(username, password); end

  # source://rack-test/2.0.2/lib/rack/test.rb#200
  def basic_authorize(username, password); end

  # source://rack-test/2.0.2/lib/rack/test.rb#125
  def clear_cookies; end

  # source://rack-test/2.0.2/lib/rack/test.rb#67
  def cookie_jar; end

  # source://rack-test/2.0.2/lib/rack/test.rb#67
  def cookie_jar=(_arg0); end

  # source://rack-test/2.0.2/lib/rack/test.rb#162
  def custom_request(verb, uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#70
  def default_host; end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def delete(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#213
  def digest_authorize(username, password); end

  # source://rack-test/2.0.2/lib/rack/test.rb#187
  def env(name, value); end

  # source://rack-test/2.0.2/lib/rack/test.rb#226
  def follow_redirect!; end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def get(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def head(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#175
  def header(name, value); end

  # source://rack-test/2.0.2/lib/rack/test.rb#136
  def last_request; end

  # source://rack-test/2.0.2/lib/rack/test.rb#143
  def last_response; end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def options(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def patch(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def post(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#113
  def put(uri, params = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#152
  def request(uri, env = T.unsafe(nil), &block); end

  # source://rack-test/2.0.2/lib/rack/test.rb#130
  def set_cookie(cookie, uri = T.unsafe(nil)); end

  private

  # source://rack-test/2.0.2/lib/rack/test.rb#338
  def append_query_params(query_array, query_params); end

  # source://rack-test/2.0.2/lib/rack/test.rb#264
  def close_body(body); end

  # source://rack-test/2.0.2/lib/rack/test.rb#401
  def digest_auth_configured?; end

  # source://rack-test/2.0.2/lib/rack/test.rb#378
  def digest_auth_header; end

  # source://rack-test/2.0.2/lib/rack/test.rb#291
  def env_for(uri, env); end

  # source://rack-test/2.0.2/lib/rack/test.rb#344
  def multipart_content_type(env); end

  # source://rack-test/2.0.2/lib/rack/test.rb#269
  def parse_uri(path, env); end

  # source://rack-test/2.0.2/lib/rack/test.rb#355
  def process_request(uri, env); end

  # source://rack-test/2.0.2/lib/rack/test.rb#395
  def retry_with_digest_auth?(env); end

  class << self
    # source://rack-test/2.0.2/lib/rack/test.rb#57
    def new(app, default_host = T.unsafe(nil)); end
  end
end

class Rack::Test::UploadedFile
  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#31
  def initialize(content, content_type = T.unsafe(nil), binary = T.unsafe(nil), original_filename: T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#58
  def append_to(buffer); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#22
  def content_type; end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#22
  def content_type=(_arg0); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#44
  def local_path; end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#50
  def method_missing(method_name, *args, &block); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#16
  def original_filename; end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#44
  def path; end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#19
  def tempfile; end

  private

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#94
  def initialize_from_file_path(path); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#88
  def initialize_from_stringio(stringio, original_filename); end

  # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#69
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#80
    def actually_finalize(file); end

    # source://rack-test/2.0.2/lib/rack/test/uploaded_file.rb#74
    def finalize(file); end
  end
end

module Rack::Test::Utils
  include ::Rack::Utils
  extend ::Rack::Utils
  extend ::Rack::Test::Utils

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#34
  def build_multipart(params, _first = T.unsafe(nil), multipart = T.unsafe(nil)); end

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#11
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  private

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#100
  def _build_parts(buffer, parameters); end

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#133
  def build_file_part(buffer, parameter_name, uploaded_file); end

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#94
  def build_parts(buffer, parameters); end

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#121
  def build_primitive_part(buffer, parameter_name, value); end

  # source://rack-test/2.0.2/lib/rack/test/utils.rb#62
  def normalize_multipart_params(params, first = T.unsafe(nil)); end
end

# source://rack-test/2.0.2/lib/rack/test/version.rb#3
Rack::Test::VERSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack.rb#47
Rack::UNLINK = T.let(T.unsafe(nil), String)

class Rack::URLMap
  # source://rack/2.2.4/lib/rack/urlmap.rb#19
  def initialize(map = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/urlmap.rb#46
  def call(env); end

  # source://rack/2.2.4/lib/rack/urlmap.rb#23
  def remap(map); end

  private

  # source://rack/2.2.4/lib/rack/urlmap.rb#85
  def casecmp?(v1, v2); end
end

module Rack::Utils
  private

  # source://rack/2.2.4/lib/rack/utils.rb#226
  def add_cookie_to_header(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#309
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#148
  def best_q_match(q_value_header, available_mimes); end

  # source://rack/2.2.4/lib/rack/utils.rb#115
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#105
  def build_query(params); end

  # source://rack/2.2.4/lib/rack/utils.rb#341
  def byte_ranges(env, size); end

  # source://rack/2.2.4/lib/rack/utils.rb#594
  def clean_path_info(path_info); end

  # source://rack/2.2.4/lib/rack/utils.rb#86
  def clock_time; end

  # source://rack/2.2.4/lib/rack/utils.rb#302
  def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#38
  def escape(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#173
  def escape_html(string); end

  # source://rack/2.2.4/lib/rack/utils.rb#44
  def escape_path(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#346
  def get_byte_ranges(http_range, size); end

  # source://rack/2.2.4/lib/rack/utils.rb#272
  def make_delete_cookie_header(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#209
  def parse_cookies(env); end

  # source://rack/2.2.4/lib/rack/utils.rb#213
  def parse_cookies_header(header); end

  # source://rack/2.2.4/lib/rack/utils.rb#101
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#97
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://rack/2.2.4/lib/rack/utils.rb#133
  def q_values(q_value_header); end

  # source://rack/2.2.4/lib/rack/utils.rb#332
  def rfc2109(time); end

  # source://rack/2.2.4/lib/rack/utils.rb#319
  def rfc2822(time); end

  # source://rack/2.2.4/lib/rack/utils.rb#380
  def secure_compare(a, b); end

  # source://rack/2.2.4/lib/rack/utils.rb#177
  def select_best_encoding(available_encodings, accept_encoding); end

  # source://rack/2.2.4/lib/rack/utils.rb#267
  def set_cookie_header!(header, key, value); end

  # source://rack/2.2.4/lib/rack/utils.rb#584
  def status_code(status); end

  # source://rack/2.2.4/lib/rack/utils.rb#56
  def unescape(s, encoding = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#50
  def unescape_path(s); end

  # source://rack/2.2.4/lib/rack/utils.rb#611
  def valid_path?(path); end

  class << self
    # source://rack/2.2.4/lib/rack/utils.rb#226
    def add_cookie_to_header(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#309
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#148
    def best_q_match(q_value_header, available_mimes); end

    # source://rack/2.2.4/lib/rack/utils.rb#115
    def build_nested_query(value, prefix = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#105
    def build_query(params); end

    # source://rack/2.2.4/lib/rack/utils.rb#341
    def byte_ranges(env, size); end

    # source://rack/2.2.4/lib/rack/utils.rb#594
    def clean_path_info(path_info); end

    # source://rack/2.2.4/lib/rack/utils.rb#86
    def clock_time; end

    # source://rack/2.2.4/lib/rack/utils.rb#29
    def default_query_parser; end

    # source://rack/2.2.4/lib/rack/utils.rb#29
    def default_query_parser=(_arg0); end

    # source://rack/2.2.4/lib/rack/utils.rb#302
    def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#38
    def escape(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#173
    def escape_html(string); end

    # source://rack/2.2.4/lib/rack/utils.rb#44
    def escape_path(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#346
    def get_byte_ranges(http_range, size); end

    # source://rack/2.2.4/lib/rack/utils.rb#77
    def key_space_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#81
    def key_space_limit=(v); end

    # source://rack/2.2.4/lib/rack/utils.rb#272
    def make_delete_cookie_header(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#61
    def multipart_part_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#61
    def multipart_part_limit=(_arg0); end

    # source://rack/2.2.4/lib/rack/utils.rb#69
    def param_depth_limit; end

    # source://rack/2.2.4/lib/rack/utils.rb#73
    def param_depth_limit=(v); end

    # source://rack/2.2.4/lib/rack/utils.rb#209
    def parse_cookies(env); end

    # source://rack/2.2.4/lib/rack/utils.rb#213
    def parse_cookies_header(header); end

    # source://rack/2.2.4/lib/rack/utils.rb#101
    def parse_nested_query(qs, d = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#97
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://rack/2.2.4/lib/rack/utils.rb#133
    def q_values(q_value_header); end

    # source://rack/2.2.4/lib/rack/utils.rb#332
    def rfc2109(time); end

    # source://rack/2.2.4/lib/rack/utils.rb#319
    def rfc2822(time); end

    # source://rack/2.2.4/lib/rack/utils.rb#380
    def secure_compare(a, b); end

    # source://rack/2.2.4/lib/rack/utils.rb#177
    def select_best_encoding(available_encodings, accept_encoding); end

    # source://rack/2.2.4/lib/rack/utils.rb#267
    def set_cookie_header!(header, key, value); end

    # source://rack/2.2.4/lib/rack/utils.rb#584
    def status_code(status); end

    # source://rack/2.2.4/lib/rack/utils.rb#56
    def unescape(s, encoding = T.unsafe(nil)); end

    # source://rack/2.2.4/lib/rack/utils.rb#50
    def unescape_path(s); end

    # source://rack/2.2.4/lib/rack/utils.rb#611
    def valid_path?(path); end
  end
end

# source://rack/2.2.4/lib/rack/utils.rb#22
Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

class Rack::Utils::Context
  # source://rack/2.2.4/lib/rack/utils.rb#398
  def initialize(app_f, app_r); end

  # source://rack/2.2.4/lib/rack/utils.rb#396
  def app; end

  # source://rack/2.2.4/lib/rack/utils.rb#403
  def call(env); end

  # source://rack/2.2.4/lib/rack/utils.rb#411
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#396
  def for; end

  # source://rack/2.2.4/lib/rack/utils.rb#407
  def recontext(app); end
end

# source://rack/2.2.4/lib/rack/utils.rb#21
Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#161
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/utils.rb#170
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#511
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Rack::Utils::HeaderHash < ::Hash
  # source://rack/2.2.4/lib/rack/utils.rb#429
  def initialize(hash = T.unsafe(nil)); end

  # source://rack/2.2.4/lib/rack/utils.rb#459
  def [](k); end

  # source://rack/2.2.4/lib/rack/utils.rb#463
  def []=(k, v); end

  # source://rack/2.2.4/lib/rack/utils.rb#442
  def clear; end

  # source://rack/2.2.4/lib/rack/utils.rb#470
  def delete(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#447
  def each; end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def has_key?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def include?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def key?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#476
  def member?(k); end

  # source://rack/2.2.4/lib/rack/utils.rb#489
  def merge(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#484
  def merge!(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#494
  def replace(other); end

  # source://rack/2.2.4/lib/rack/utils.rb#453
  def to_hash; end

  protected

  # source://rack/2.2.4/lib/rack/utils.rb#501
  def names; end

  private

  # source://rack/2.2.4/lib/rack/utils.rb#436
  def initialize_copy(other); end

  class << self
    # source://rack/2.2.4/lib/rack/utils.rb#421
    def [](headers); end
  end
end

# source://rack/2.2.4/lib/rack/utils.rb#20
Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

# source://rack/2.2.4/lib/rack/utils.rb#23
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

# source://rack/2.2.4/lib/rack/utils.rb#609
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://rack/2.2.4/lib/rack/utils.rb#592
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.4/lib/rack/utils.rb#19
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# source://rack/2.2.4/lib/rack/utils.rb#25
Rack::Utils::RFC2822_DAY_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/utils.rb#26
Rack::Utils::RFC2822_MONTH_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.4/lib/rack/utils.rb#578
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/utils.rb#580
Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.4/lib/rack/version.rb#16
Rack::VERSION = T.let(T.unsafe(nil), Array)

module Rails::Initializable
  mixes_in_class_methods ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/initializable.rb#66
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#58
  def run_initializers(group = T.unsafe(nil), *args); end

  class << self
    # source://railties/7.0.4/lib/rails/initializable.rb#7
    def included(base); end
  end
end

module Rails::Initializable::ClassMethods
  # source://railties/7.0.4/lib/rails/initializable.rb#88
  def initializer(name, opts = T.unsafe(nil), &blk); end

  # source://railties/7.0.4/lib/rails/initializable.rb#71
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#75
  def initializers_chain; end

  # source://railties/7.0.4/lib/rails/initializable.rb#84
  def initializers_for(binding); end
end

class Rails::Initializable::Collection < ::Array
  include ::TSort

  # source://railties/7.0.4/lib/rails/initializable.rb#53
  def +(other); end

  # source://railties/7.0.4/lib/rails/initializable.rb#49
  def tsort_each_child(initializer, &block); end

  def tsort_each_node; end
end

class Rails::Initializable::Initializer
  # source://railties/7.0.4/lib/rails/initializable.rb#14
  def initialize(name, context, options, &block); end

  # source://railties/7.0.4/lib/rails/initializable.rb#23
  def after; end

  # source://railties/7.0.4/lib/rails/initializable.rb#19
  def before; end

  # source://railties/7.0.4/lib/rails/initializable.rb#27
  def belongs_to?(group); end

  # source://railties/7.0.4/lib/rails/initializable.rb#35
  def bind(context); end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def block; end

  # source://railties/7.0.4/lib/rails/initializable.rb#40
  def context_class; end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def name; end

  # source://railties/7.0.4/lib/rails/initializable.rb#31
  def run(*args); end
end

class Rails::Railtie
  include ::Rails::Initializable
  extend ::ActiveSupport::DescendantsTracker
  extend ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/railtie.rb#246
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie.rb#263
  def config; end

  # source://railties/7.0.4/lib/rails/railtie.rb#256
  def configure(&block); end

  # source://railties/7.0.4/lib/rails/railtie.rb#252
  def inspect; end

  # source://railties/7.0.4/lib/rails/railtie.rb#244
  def railtie_name(*_arg0, **_arg1, &_arg2); end

  # source://railties/7.0.4/lib/rails/railtie.rb#267
  def railtie_namespace; end

  protected

  # source://railties/7.0.4/lib/rails/railtie.rb#272
  def run_console_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#276
  def run_generators_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#280
  def run_runner_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#289
  def run_server_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#284
  def run_tasks_blocks(app); end

  private

  # source://railties/7.0.4/lib/rails/railtie.rb#295
  def each_registered_block(type, &block); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie.rb#194
    def <=>(other); end

    # source://railties/7.0.4/lib/rails/railtie.rb#172
    def abstract_railtie?; end

    # source://railties/7.0.4/lib/rails/railtie.rb#146
    def config(*_arg0, **_arg1, &_arg2); end

    # source://railties/7.0.4/lib/rails/railtie.rb#190
    def configure(&block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#156
    def console(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#164
    def generators(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#198
    def inherited(subclass); end

    # source://railties/7.0.4/lib/rails/railtie.rb#183
    def instance; end

    # source://railties/7.0.4/lib/rails/railtie.rb#176
    def railtie_name(name = T.unsafe(nil)); end

    # source://railties/7.0.4/lib/rails/railtie.rb#152
    def rake_tasks(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#160
    def runner(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#168
    def server(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#148
    def subclasses; end

    protected

    # source://railties/7.0.4/lib/rails/railtie.rb#206
    def increment_load_index; end

    # source://railties/7.0.4/lib/rails/railtie.rb#204
    def load_index; end

    private

    # source://railties/7.0.4/lib/rails/railtie.rb#212
    def generate_railtie_name(string); end

    # source://railties/7.0.4/lib/rails/railtie.rb#224
    def method_missing(name, *args, **_arg2, &block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#236
    def register_block_for(type, &blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#216
    def respond_to_missing?(name, _); end
  end
end

# source://railties/7.0.4/lib/rails/railtie.rb#142
Rails::Railtie::ABSTRACT_RAILTIES = T.let(T.unsafe(nil), Array)

class Rails::Railtie::Configuration
  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#8
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#70
  def after_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#47
  def app_generators; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#39
  def app_middleware; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#54
  def before_configuration(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#60
  def before_eager_load(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#65
  def before_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#18
  def eager_load_namespaces; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#85
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#81
  def to_prepare(&blk); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#75
  def to_prepare_blocks; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#30
  def watchable_dirs; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#23
  def watchable_files; end

  private

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#90
  def method_missing(name, *args, &blk); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie/configuration.rb#13
    def eager_load_namespaces; end
  end
end
