# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `globalid` gem.
# Please instead update this file by running `bin/tapioca gem globalid`.

module ActiveSupport::Autoload
  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#37
  def autoload(const_name, path = T.unsafe(nil)); end

  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#57
  def autoload_at(path); end

  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#50
  def autoload_under(path); end

  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#75
  def autoloads; end

  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#64
  def eager_autoload; end

  # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#71
  def eager_load!; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/dependencies/autoload.rb#28
    def extended(base); end
  end
end

module ActiveSupport::DescendantsTracker
  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#88
  def descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#92
  def direct_descendants; end

  # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#82
  def subclasses; end

  class << self
    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#66
    def clear(classes); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#62
    def descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#11
    def direct_descendants(klass); end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#50
    def disable_clear!; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#77
    def native?; end

    # source://activesupport/7.0.4/lib/active_support/descendants_tracker.rb#58
    def subclasses(klass); end
  end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator
  include ::ActiveSupport::Messages::Rotator::Verifier

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#6
  def initialize(*secrets, on_rotation: T.unsafe(nil), **options); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#188
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#126
  def valid_message?(signed_message); end

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#36
  def verified(*args, on_rotation: T.unsafe(nil), **options); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#177
  def verify(*args, **options); end

  private

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#198
  def decode(data); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#206
  def digest_length_in_hex; end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#233
  def digest_matches_data?(digest, data); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#194
  def encode(data); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#202
  def generate_digest(data); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#221
  def get_data_and_digest_from(signed_message); end

  # source://activesupport/7.0.4/lib/active_support/message_verifier.rb#214
  def separator_index_for(signed_message); end
end

class ActiveSupport::MessageVerifier::InvalidSignature < ::StandardError; end

# source://activesupport/7.0.4/lib/active_support/message_verifier.rb#107
ActiveSupport::MessageVerifier::SEPARATOR = T.let(T.unsafe(nil), String)

# source://activesupport/7.0.4/lib/active_support/message_verifier.rb#108
ActiveSupport::MessageVerifier::SEPARATOR_LENGTH = T.let(T.unsafe(nil), Integer)

module ActiveSupport::Messages::Rotator
  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#6
  def initialize(*secrets, on_rotation: T.unsafe(nil), **options); end

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#14
  def rotate(*secrets, **options); end

  private

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#47
  def run_rotations(on_rotation); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#21
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end

  private

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#28
  def build_rotation(secret = T.unsafe(nil), sign_secret = T.unsafe(nil), options); end
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#36
  def verified(*args, on_rotation: T.unsafe(nil), **options); end

  private

  # source://activesupport/7.0.4/lib/active_support/messages/rotator.rb#41
  def build_rotation(secret = T.unsafe(nil), options); end
end

class GlobalID
  extend ::ActiveSupport::Autoload

  # @return [GlobalID] a new instance of GlobalID
  #
  # source://globalid//lib/global_id/global_id.rb#51
  def initialize(gid, options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/global_id.rb#63
  def ==(other); end

  # source://globalid//lib/global_id/global_id.rb#49
  def app(*_arg0, **_arg1, &_arg2); end

  # source://globalid//lib/global_id/global_id.rb#63
  def eql?(other); end

  # source://globalid//lib/global_id/global_id.rb#55
  def find(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/global_id.rb#68
  def hash; end

  # source://globalid//lib/global_id/global_id.rb#59
  def model_class; end

  # source://globalid//lib/global_id/global_id.rb#49
  def model_id(*_arg0, **_arg1, &_arg2); end

  # source://globalid//lib/global_id/global_id.rb#49
  def model_name(*_arg0, **_arg1, &_arg2); end

  # source://globalid//lib/global_id/global_id.rb#49
  def params(*_arg0, **_arg1, &_arg2); end

  # source://globalid//lib/global_id/global_id.rb#72
  def to_param; end

  # source://globalid//lib/global_id/global_id.rb#49
  def to_s(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute uri.
  #
  # source://globalid//lib/global_id/global_id.rb#48
  def uri; end

  class << self
    # Returns the value of attribute app.
    #
    # source://globalid//lib/global_id/global_id.rb#10
    def app; end

    # source://globalid//lib/global_id/global_id.rb#32
    def app=(app); end

    # source://globalid//lib/global_id/global_id.rb#12
    def create(model, options = T.unsafe(nil)); end

    # source://globalid//lib/global_id.rb#15
    def eager_load!; end

    # source://globalid//lib/global_id/global_id.rb#22
    def find(gid, options = T.unsafe(nil)); end

    # source://globalid//lib/global_id/global_id.rb#26
    def parse(gid, options = T.unsafe(nil)); end

    private

    # source://globalid//lib/global_id/global_id.rb#37
    def parse_encoded_gid(gid, options); end

    # We removed the base64 padding character = during #to_param, now we're adding it back so decoding will work
    #
    # source://globalid//lib/global_id/global_id.rb#42
    def repad_gid(gid); end
  end
end

module GlobalID::Identification
  # source://globalid//lib/global_id/identification.rb#3
  def to_gid(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/identification.rb#8
  def to_gid_param(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/identification.rb#3
  def to_global_id(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/identification.rb#12
  def to_sgid(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/identification.rb#17
  def to_sgid_param(options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/identification.rb#12
  def to_signed_global_id(options = T.unsafe(nil)); end
end

module GlobalID::Locator
  class << self
    # Takes either a GlobalID or a string that can be turned into a GlobalID
    #
    # Options:
    # * <tt>:only</tt> - A class, module or Array of classes and/or modules that are
    #   allowed to be located.  Passing one or more classes limits instances of returned
    #   classes to those classes or their subclasses.  Passing one or more modules in limits
    #   instances of returned classes to those including that module.  If no classes or
    #   modules match, +nil+ is returned.
    #
    # source://globalid//lib/global_id/locator.rb#15
    def locate(gid, options = T.unsafe(nil)); end

    # Takes an array of GlobalIDs or strings that can be turned into a GlobalIDs.
    # All GlobalIDs must belong to the same app, as they will be located using
    # the same locator using its locate_many method.
    #
    # By default the GlobalIDs will be located using Model.find(array_of_ids), so the
    # models must respond to that finder signature.
    #
    # This approach will efficiently call only one #find (or #where(id: id), when using ignore_missing)
    # per model class, but still interpolate the results to match the order in which the gids were passed.
    #
    # Options:
    # * <tt>:only</tt> - A class, module or Array of classes and/or modules that are
    #   allowed to be located.  Passing one or more classes limits instances of returned
    #   classes to those classes or their subclasses.  Passing one or more modules in limits
    #   instances of returned classes to those including that module.  If no classes or
    #   modules match, +nil+ is returned.
    # * <tt>:ignore_missing</tt> - By default, locate_many will call #find on the model to locate the
    #   ids extracted from the GIDs. In Active Record (and other data stores following the same pattern),
    #   #find will raise an exception if a named ID can't be found. When you set this option to true,
    #   we will use #where(id: ids) instead, which does not raise on missing records.
    #
    # source://globalid//lib/global_id/locator.rb#41
    def locate_many(gids, options = T.unsafe(nil)); end

    # Takes an array of SignedGlobalIDs or strings that can be turned into a SignedGlobalIDs.
    # The SignedGlobalIDs are located using Model.find(array_of_ids), so the models must respond to
    # that finder signature.
    #
    # This approach will efficiently call only one #find per model class, but still interpolate
    # the results to match the order in which the gids were passed.
    #
    # Options:
    # * <tt>:only</tt> - A class, module or Array of classes and/or modules that are
    #   allowed to be located.  Passing one or more classes limits instances of returned
    #   classes to those classes or their subclasses.  Passing one or more modules in limits
    #   instances of returned classes to those including that module.  If no classes or
    #   modules match, +nil+ is returned.
    #
    # source://globalid//lib/global_id/locator.rb#75
    def locate_many_signed(sgids, options = T.unsafe(nil)); end

    # Takes either a SignedGlobalID or a string that can be turned into a SignedGlobalID
    #
    # Options:
    # * <tt>:only</tt> - A class, module or Array of classes and/or modules that are
    #   allowed to be located.  Passing one or more classes limits instances of returned
    #   classes to those classes or their subclasses.  Passing one or more modules in limits
    #   instances of returned classes to those including that module.  If no classes or
    #   modules match, +nil+ is returned.
    #
    # source://globalid//lib/global_id/locator.rb#58
    def locate_signed(sgid, options = T.unsafe(nil)); end

    # Tie a locator to an app.
    # Useful when different apps collaborate and reference each others' Global IDs.
    #
    # The locator can be either a block or a class.
    #
    # Using a block:
    #
    #   GlobalID::Locator.use :foo do |gid|
    #     FooRemote.const_get(gid.model_name).find(gid.model_id)
    #   end
    #
    # Using a class:
    #
    #   GlobalID::Locator.use :bar, BarLocator.new
    #
    #   class BarLocator
    #     def locate(gid)
    #       @search_client.search name: gid.model_name, id: gid.model_id
    #     end
    #   end
    #
    # @raise [ArgumentError]
    #
    # source://globalid//lib/global_id/locator.rb#99
    def use(app, locator = T.unsafe(nil), &locator_block); end

    private

    # @return [Boolean]
    #
    # source://globalid//lib/global_id/locator.rb#112
    def find_allowed?(model_class, only = T.unsafe(nil)); end

    # source://globalid//lib/global_id/locator.rb#108
    def locator_for(gid); end

    # source://globalid//lib/global_id/locator.rb#120
    def normalize_app(app); end

    # source://globalid//lib/global_id/locator.rb#116
    def parse_allowed(gids, only = T.unsafe(nil)); end
  end
end

class GlobalID::Locator::BaseLocator
  # source://globalid//lib/global_id/locator.rb#129
  def locate(gid); end

  # source://globalid//lib/global_id/locator.rb#133
  def locate_many(gids, options = T.unsafe(nil)); end

  private

  # source://globalid//lib/global_id/locator.rb#144
  def find_records(model_class, ids, options); end
end

class GlobalID::Locator::BlockLocator
  # @return [BlockLocator] a new instance of BlockLocator
  #
  # source://globalid//lib/global_id/locator.rb#174
  def initialize(block); end

  # source://globalid//lib/global_id/locator.rb#178
  def locate(gid); end

  # source://globalid//lib/global_id/locator.rb#182
  def locate_many(gids, options = T.unsafe(nil)); end
end

# source://globalid//lib/global_id/locator.rb#171
GlobalID::Locator::DEFAULT_LOCATOR = T.let(T.unsafe(nil), GlobalID::Locator::UnscopedLocator)

class GlobalID::Locator::UnscopedLocator < ::GlobalID::Locator::BaseLocator
  # source://globalid//lib/global_id/locator.rb#154
  def locate(gid); end

  private

  # source://globalid//lib/global_id/locator.rb#159
  def find_records(model_class, ids, options); end

  # source://globalid//lib/global_id/locator.rb#163
  def unscoped(model_class); end
end

class GlobalID::Railtie < ::Rails::Railtie; end

class GlobalID::Verifier < ::ActiveSupport::MessageVerifier
  private

  # source://globalid//lib/global_id/verifier.rb#11
  def decode(data); end

  # source://globalid//lib/global_id/verifier.rb#7
  def encode(data); end
end

module Rails::Initializable
  mixes_in_class_methods ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/initializable.rb#66
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#58
  def run_initializers(group = T.unsafe(nil), *args); end

  class << self
    # source://railties/7.0.4/lib/rails/initializable.rb#7
    def included(base); end
  end
end

module Rails::Initializable::ClassMethods
  # source://railties/7.0.4/lib/rails/initializable.rb#88
  def initializer(name, opts = T.unsafe(nil), &blk); end

  # source://railties/7.0.4/lib/rails/initializable.rb#71
  def initializers; end

  # source://railties/7.0.4/lib/rails/initializable.rb#75
  def initializers_chain; end

  # source://railties/7.0.4/lib/rails/initializable.rb#84
  def initializers_for(binding); end
end

class Rails::Initializable::Collection < ::Array
  include ::TSort

  # source://railties/7.0.4/lib/rails/initializable.rb#53
  def +(other); end

  # source://railties/7.0.4/lib/rails/initializable.rb#49
  def tsort_each_child(initializer, &block); end

  def tsort_each_node; end
end

class Rails::Initializable::Initializer
  # source://railties/7.0.4/lib/rails/initializable.rb#14
  def initialize(name, context, options, &block); end

  # source://railties/7.0.4/lib/rails/initializable.rb#23
  def after; end

  # source://railties/7.0.4/lib/rails/initializable.rb#19
  def before; end

  # source://railties/7.0.4/lib/rails/initializable.rb#27
  def belongs_to?(group); end

  # source://railties/7.0.4/lib/rails/initializable.rb#35
  def bind(context); end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def block; end

  # source://railties/7.0.4/lib/rails/initializable.rb#40
  def context_class; end

  # source://railties/7.0.4/lib/rails/initializable.rb#12
  def name; end

  # source://railties/7.0.4/lib/rails/initializable.rb#31
  def run(*args); end
end

class Rails::Railtie
  include ::Rails::Initializable
  extend ::ActiveSupport::DescendantsTracker
  extend ::Rails::Initializable::ClassMethods

  # source://railties/7.0.4/lib/rails/railtie.rb#246
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie.rb#263
  def config; end

  # source://railties/7.0.4/lib/rails/railtie.rb#256
  def configure(&block); end

  # source://railties/7.0.4/lib/rails/railtie.rb#252
  def inspect; end

  # source://railties/7.0.4/lib/rails/railtie.rb#244
  def railtie_name(*_arg0, **_arg1, &_arg2); end

  # source://railties/7.0.4/lib/rails/railtie.rb#267
  def railtie_namespace; end

  protected

  # source://railties/7.0.4/lib/rails/railtie.rb#272
  def run_console_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#276
  def run_generators_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#280
  def run_runner_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#289
  def run_server_blocks(app); end

  # source://railties/7.0.4/lib/rails/railtie.rb#284
  def run_tasks_blocks(app); end

  private

  # source://railties/7.0.4/lib/rails/railtie.rb#295
  def each_registered_block(type, &block); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie.rb#194
    def <=>(other); end

    # source://railties/7.0.4/lib/rails/railtie.rb#172
    def abstract_railtie?; end

    # source://railties/7.0.4/lib/rails/railtie.rb#146
    def config(*_arg0, **_arg1, &_arg2); end

    # source://railties/7.0.4/lib/rails/railtie.rb#190
    def configure(&block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#156
    def console(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#164
    def generators(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#198
    def inherited(subclass); end

    # source://railties/7.0.4/lib/rails/railtie.rb#183
    def instance; end

    # source://railties/7.0.4/lib/rails/railtie.rb#176
    def railtie_name(name = T.unsafe(nil)); end

    # source://railties/7.0.4/lib/rails/railtie.rb#152
    def rake_tasks(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#160
    def runner(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#168
    def server(&blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#148
    def subclasses; end

    protected

    # source://railties/7.0.4/lib/rails/railtie.rb#206
    def increment_load_index; end

    # source://railties/7.0.4/lib/rails/railtie.rb#204
    def load_index; end

    private

    # source://railties/7.0.4/lib/rails/railtie.rb#212
    def generate_railtie_name(string); end

    # source://railties/7.0.4/lib/rails/railtie.rb#224
    def method_missing(name, *args, **_arg2, &block); end

    # source://railties/7.0.4/lib/rails/railtie.rb#236
    def register_block_for(type, &blk); end

    # source://railties/7.0.4/lib/rails/railtie.rb#216
    def respond_to_missing?(name, _); end
  end
end

# source://railties/7.0.4/lib/rails/railtie.rb#142
Rails::Railtie::ABSTRACT_RAILTIES = T.let(T.unsafe(nil), Array)

class Rails::Railtie::Configuration
  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#8
  def initialize; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#70
  def after_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#47
  def app_generators; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#39
  def app_middleware; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#54
  def before_configuration(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#60
  def before_eager_load(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#65
  def before_initialize(&block); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#18
  def eager_load_namespaces; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#85
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#81
  def to_prepare(&blk); end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#75
  def to_prepare_blocks; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#30
  def watchable_dirs; end

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#23
  def watchable_files; end

  private

  # source://railties/7.0.4/lib/rails/railtie/configuration.rb#90
  def method_missing(name, *args, &blk); end

  class << self
    # source://railties/7.0.4/lib/rails/railtie/configuration.rb#13
    def eager_load_namespaces; end
  end
end

class SignedGlobalID < ::GlobalID
  # @return [SignedGlobalID] a new instance of SignedGlobalID
  #
  # source://globalid//lib/global_id/signed_global_id.rb#51
  def initialize(gid, options = T.unsafe(nil)); end

  # source://globalid//lib/global_id/signed_global_id.rb#69
  def ==(other); end

  # Returns the value of attribute expires_at.
  #
  # source://globalid//lib/global_id/signed_global_id.rb#49
  def expires_at; end

  # Returns the value of attribute purpose.
  #
  # source://globalid//lib/global_id/signed_global_id.rb#49
  def purpose; end

  # source://globalid//lib/global_id/signed_global_id.rb#63
  def to_h; end

  # source://globalid//lib/global_id/signed_global_id.rb#58
  def to_param; end

  # source://globalid//lib/global_id/signed_global_id.rb#58
  def to_s; end

  # Returns the value of attribute verifier.
  #
  # source://globalid//lib/global_id/signed_global_id.rb#49
  def verifier; end

  private

  # source://globalid//lib/global_id/signed_global_id.rb#74
  def encoded_expiration; end

  # source://globalid//lib/global_id/signed_global_id.rb#78
  def pick_expiration(options); end

  class << self
    # Returns the value of attribute expires_in.
    #
    # source://globalid//lib/global_id/signed_global_id.rb#23
    def expires_in; end

    # Sets the attribute expires_in
    #
    # @param value the value to set the attribute expires_in to.
    #
    # source://globalid//lib/global_id/signed_global_id.rb#23
    def expires_in=(_arg0); end

    # source://globalid//lib/global_id/signed_global_id.rb#11
    def parse(sgid, options = T.unsafe(nil)); end

    # source://globalid//lib/global_id/signed_global_id.rb#27
    def pick_purpose(options); end

    # Grab the verifier from options and fall back to SignedGlobalID.verifier.
    # Raise ArgumentError if neither is available.
    #
    # source://globalid//lib/global_id/signed_global_id.rb#17
    def pick_verifier(options); end

    # Returns the value of attribute verifier.
    #
    # source://globalid//lib/global_id/signed_global_id.rb#9
    def verifier; end

    # Sets the attribute verifier
    #
    # @param value the value to set the attribute verifier to.
    #
    # source://globalid//lib/global_id/signed_global_id.rb#9
    def verifier=(_arg0); end

    private

    # source://globalid//lib/global_id/signed_global_id.rb#42
    def raise_if_expired(expires_at); end

    # source://globalid//lib/global_id/signed_global_id.rb#32
    def verify(sgid, options); end
  end
end

class SignedGlobalID::ExpiredMessage < ::StandardError; end

class URI::GID < ::URI::Generic
  # URI::GID encodes an app unique reference to a specific model as an URI.
  # It has the components: app name, model class name, model id and params.
  # All components except params are required.
  #
  # The URI format looks like "gid://app/model_name/model_id".
  #
  # Simple metadata can be stored in params. Useful if your app has multiple databases,
  # for instance, and you need to find out which one to look up the model in.
  #
  # Params will be encoded as query parameters like so
  # "gid://app/model_name/model_id?key=value&another_key=another_value".
  #
  # Params won't be typecast, they're always strings.
  # For convenience params can be accessed using both strings and symbol keys.
  #
  # Multi value params aren't supported. Any params encoding multiple values under
  # the same key will return only the last value. For example, when decoding
  # params like "key=first_value&key=last_value" key will only be last_value.
  #
  # Read the documentation for +parse+, +create+ and +build+ for more.
  #
  # source://uri/0.11.0/uri/generic.rb#243
  def app; end

  # Returns the value of attribute model_id.
  #
  # source://globalid//lib/global_id/uri/gid.rb#29
  def model_id; end

  # Returns the value of attribute model_name.
  #
  # source://globalid//lib/global_id/uri/gid.rb#29
  def model_name; end

  # Returns the value of attribute params.
  #
  # source://globalid//lib/global_id/uri/gid.rb#29
  def params; end

  # source://globalid//lib/global_id/uri/gid.rb#96
  def to_s; end

  protected

  # Ruby 2.2 uses #query= instead of #set_query
  #
  # source://globalid//lib/global_id/uri/gid.rb#108
  def query=(query); end

  # source://globalid//lib/global_id/uri/gid.rb#119
  def set_params(params); end

  # source://globalid//lib/global_id/uri/gid.rb#102
  def set_path(path); end

  # Ruby 2.1 or less uses #set_query to assign the query
  #
  # source://globalid//lib/global_id/uri/gid.rb#114
  def set_query(query); end

  private

  # source://globalid//lib/global_id/uri/gid.rb#129
  def check_host(host); end

  # source://globalid//lib/global_id/uri/gid.rb#134
  def check_path(path); end

  # source://globalid//lib/global_id/uri/gid.rb#139
  def check_scheme(scheme); end

  # source://globalid//lib/global_id/uri/gid.rb#171
  def parse_query_params(query); end

  # source://globalid//lib/global_id/uri/gid.rb#147
  def set_model_components(path, validate = T.unsafe(nil)); end

  # @raise [URI::InvalidComponentError]
  #
  # source://globalid//lib/global_id/uri/gid.rb#157
  def validate_component(component); end

  # @raise [MissingModelIdError]
  #
  # source://globalid//lib/global_id/uri/gid.rb#164
  def validate_model_id(model_id, model_name); end

  class << self
    # Create a new URI::GID from components with argument check.
    #
    # The allowed components are app, model_name, model_id and params, which can be
    # either a hash or an array.
    #
    # Using a hash:
    #
    #   URI::GID.build(app: 'bcx', model_name: 'Person', model_id: '1', params: { key: 'value' })
    #
    # Using an array, the arguments must be in order [app, model_name, model_id, params]:
    #
    #   URI::GID.build(['bcx', 'Person', '1', key: 'value'])
    #
    # source://globalid//lib/global_id/uri/gid.rb#83
    def build(args); end

    # Shorthand to build a URI::GID from an app, a model and optional params.
    #
    #   URI::GID.create('bcx', Person.find(5), database: 'superhumans')
    #
    # source://globalid//lib/global_id/uri/gid.rb#67
    def create(app, model, params = T.unsafe(nil)); end

    # Create a new URI::GID by parsing a gid string with argument check.
    #
    #   URI::GID.parse 'gid://bcx/Person/1?key=value'
    #
    # This differs from URI() and URI.parse which do not check arguments.
    #
    #   URI('gid://bcx')             # => URI::GID instance
    #   URI.parse('gid://bcx')       # => URI::GID instance
    #   URI::GID.parse('gid://bcx/') # => raises URI::InvalidComponentError
    #
    # source://globalid//lib/global_id/uri/gid.rb#59
    def parse(uri); end

    # Validates +app+'s as URI hostnames containing only alphanumeric characters
    # and hyphens. An ArgumentError is raised if +app+ is invalid.
    #
    #   URI::GID.validate_app('bcx')     # => 'bcx'
    #   URI::GID.validate_app('foo-bar') # => 'foo-bar'
    #
    #   URI::GID.validate_app(nil)       # => ArgumentError
    #   URI::GID.validate_app('foo/bar') # => ArgumentError
    #
    # source://globalid//lib/global_id/uri/gid.rb#43
    def validate_app(app); end
  end
end

# source://globalid//lib/global_id/uri/gid.rb#124
URI::GID::COMPONENT = T.let(T.unsafe(nil), Array)

# Raised when creating a Global ID for a model without an id
class URI::GID::MissingModelIdError < ::URI::InvalidComponentError; end

# Extracts model_name and model_id from the URI path.
#
# source://globalid//lib/global_id/uri/gid.rb#127
URI::GID::PATH_REGEXP = T.let(T.unsafe(nil), Regexp)
